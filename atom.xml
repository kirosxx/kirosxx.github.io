<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cm&#39;s blog</title>
  
  
  <link href="http://cmblogs.cn/atom.xml" rel="self"/>
  
  <link href="http://cmblogs.cn/"/>
  <updated>2021-12-26T06:54:09.975Z</updated>
  <id>http://cmblogs.cn/</id>
  
  <author>
    <name>Kiros</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程池任务提交方法submit()和execute()的区别</title>
    <link href="http://cmblogs.cn/2021/12/24/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95submit()%E5%92%8Cexcute()%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>http://cmblogs.cn/2021/12/24/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95submit()%E5%92%8Cexcute()%E7%9A%84%E5%8C%BA%E5%88%AB.html</id>
    <published>2021-12-24T14:50:05.000Z</published>
    <updated>2021-12-26T06:54:09.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li><p><strong>返回值：</strong>execute() 没有返回值，submit() 有返回值Future，并且结合Callable任务指定泛型，可以通过future.get()拿到对应Callable返回的对象。</p></li><li><p><strong>接受的任务类型：</strong>execute() 方法只能接受Runnable类型，submit() 方法可以接受Runnable和Callable类型，但是因为Runnable类型的run方法返回值是void，所以future.get()的会是null。</p></li><li><p><strong>抛出异常：</strong> </p><span id="more"></span><ul><li>execute中的是Runnable接口的实现，所以只能使用try、catch来捕获CheckedException，通过实现UncaughtExceptionHande接口处理UncheckedException，<strong>即和普通线程的处理方式完全一致。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnableTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    service.execute(runnableTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="C:\Users\kiros\AppData\Roaming\Typora\typora-user-images\image-20211225213059401.png" alt="image-20211225213059401"></p><ul><li>submit提交的无论是Runnable还是Callable任务，<strong>如果不调用future.get()都会吃掉异常，需要对异常进行捕获：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Future&lt;?&gt; future = service.submit(runnableTask);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.err.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果：</li></ul><p><img src="C:\Users\kiros\AppData\Roaming\Typora\typora-user-images\image-20211225214838630.png" alt="image-20211225214838630"></p></li></ol><p>​        </p><p>​        </p><h2 id="demo代码"><a href="#demo代码" class="headerlink" title="demo代码"></a>demo代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        Runnable runnableTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; callableTask = <span class="keyword">new</span> Callable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;callableTask---当前线程:&quot;</span> + Thread.currentThread().getName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//            service.execute(runnableTask);</span></span><br><span class="line">            Future&lt;?&gt; future = service.submit(runnableTask);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(future.get());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.err.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;返回值：&lt;/strong&gt;execute() 没有返回值，submit() 有返回值Future，并且结合Callable任务指定泛型，可以通过future.get()拿到对应Callable返回的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;接受的任务类型：&lt;/strong&gt;execute() 方法只能接受Runnable类型，submit() 方法可以接受Runnable和Callable类型，但是因为Runnable类型的run方法返回值是void，所以future.get()的会是null。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;抛出异常：&lt;/strong&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="学习记录" scheme="http://cmblogs.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Java" scheme="http://cmblogs.cn/tags/Java/"/>
    
    <category term="线程池" scheme="http://cmblogs.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于幂等问题</title>
    <link href="http://cmblogs.cn/2021/11/24/%E5%B9%82%E7%AD%89%E6%80%A7%E9%97%AE%E9%A2%98.html"/>
    <id>http://cmblogs.cn/2021/11/24/%E5%B9%82%E7%AD%89%E6%80%A7%E9%97%AE%E9%A2%98.html</id>
    <published>2021-11-23T16:09:24.000Z</published>
    <updated>2021-11-23T16:18:04.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="幂等的作用"><a href="#幂等的作用" class="headerlink" title="幂等的作用"></a>幂等的作用</h2><p>无论是单机或者分布式系统都会遇到并发的问题，除了使用类似流量控制等的方法之外，当请求真正到达后端服务器之后，幂等设计就可以作为一种解决方案了。</p><p>基于消息队列的分布式架构的系统中，由于各种原因，比如网络波动等，队列里面的消息就会重发，从本质上来说，系统自动产生了一个并发请求。简单一点也可以理解为一个webapi接口被完全“相同”的参数调用了多次，这时候幂等就派上用处了。</p><span id="more"></span><p><code>参考文章：</code><br><a href="https://www.jianshu.com/p/2927542c6dd9">什么是幂等？分布式锁如何实现业务幂等？</a><br>                <a href="https://ld246.com/article/1593579328218">如何保证接口的幂等性？</a></p><h2 id="前端层面实现"><a href="#前端层面实现" class="headerlink" title="前端层面实现"></a>前端层面实现</h2><p>从前端考虑解决幂等问题主要有三种方式：<strong>前端防重、PRG模式、Token机制</strong></p><ol><li><strong>前端防重</strong><br>  通过前端防重保证幂等是最简单的实现方式，前端相关属性和JS代码即可完成设置。可靠性并不好，有经验的人员可以通过工具跳过页面仍能重复提交。主要适用于表单重复提交或按钮重复点击。</li><li><strong>PRG模式</strong><br>   即POST-REDIRECT-GET，是一种比较常见的前端防重策略。当用户进行表单提交时，会重定向到另外一个提交成功页面，而不是停留在原先的表单页面。这样就避免了用户刷新导致重复提交。同时防止了通过浏览器按钮前进/后退导致表单重复提交。</li><li><strong>使用token</strong><br>通过token机制来保证幂等是一种非常常见的解决方案，同时也适合绝大部分场景。该方案需要前后端进行一定程度的交互来完成。<br><img src="https://img-blog.csdnimg.cn/f9fced8ce0d942a4af07c832b4aa7d71.png" alt="在这里插入图片描述"></li></ol><p><strong>但是这种先执行业务再删除token的方案会有问题</strong>。在高并发情况下，很有可能出现第一次访问时token存在，完成具体业务操作。但在还没有删除token时，客户端又携带token发起请求，此时，因为token还存在，第二次请求也会验证通过，执行具体业务操作。</p><p>解决这个并发问题的核心思想就是并行变串行，会造成一定性能损耗与吞吐量降低。</p><p><strong>第一种方案</strong>：对于业务代码执行和删除token整体加线程锁。当后续线程再来访问时，则阻塞排队。<br><strong>第二种方案</strong>：借助redis单线程和incr是原子性的特点。当第一次获取token时，以token作为key，对其进行自增。<br>然后将token进行返回，当客户端携带token访问执行业务代码时，对于判断token是否存在不用删除，而是对其继续incr。如果incr后的返回值为2。则是一个合法请求允许执行，如果是其他值，则代表是非法请求，直接返回。</p><p><strong>那如果先删除token再执行业务呢</strong>？其实也会存在问题，假设具体业务代码执行超时或失败，没有向客户端返回明确结果，那客户端就很有可能会进行重试，但此时之前的token已经被删除了，则会被认为是重复请求，不再进行业务处理。</p><p>这种方案无需进行额外处理，一个token只能代表一次请求。一旦业务执行出现异常，则让客户端重新获取令牌，重新发起一次访问即可。推荐使用先删除token方案。<br>但是无论先删token还是后删token，都会有一个相同的问题。每次业务请求都回产生一个额外的请求去获取token。但是，业务失败或超时，在生产环境下，一万个里最多也就十个左右会失败，那为了这十来个请求，让其他九千九百多个请求都产生额外请求，就有一些得不偿失了。虽然redis性能好，但是这也是一种资源的浪费。</p><h2 id="数据库层面实现"><a href="#数据库层面实现" class="headerlink" title="数据库层面实现"></a>数据库层面实现</h2><p>数据库实现幂等性的方案有两个：</p><ol><li><p>乐观锁</p><p> mysql乐观锁更适用于一些需要计数的表上，而且在竞争不激烈，出现并发冲突几率较小时，推荐使用乐观锁。虽然通过MySQL乐观锁可以完成并发控制，但锁的操作是直接作用于数据库上，这样就会在一定程度上对数据库性能产生影响。并且mysql的连接数量是有限的，如果出现大量锁操作占用连接时，也会造成MySQL的性能瓶颈。</p></li></ol><ol start="2"><li><p>防重表（唯一索引）</p><p> 对于防止数据重复提交，有一种解决方案就是通过防重表实现。防重表的实现思路也非常简单。首先创建一张表作为防重表，同时在该表中建立一个或多个字段的唯一索引作为防重字段，用于保证并发情况下，数据只有一条。在向业务表中插入数据之前先向防重表插入，如果插入失败则表示是重复数据。</p><p> 对于防重表的解决方案，可能有人会说为什么不使用悲观锁。悲观锁在使用的过程中也是会发生死锁的。悲观锁是通过锁表的方式实现的。 假设现在一个用户A访问表A（锁住了表A），然后试图访问表B； 另一个用户B访问表B（锁住了表B），然后试图访问表A。 这时对于用户A来说，由于表B已经被用户B锁住了，所以用户A必须等到用户B释放表B才能访问。 同时对于用户B来说，由于表A已经被用户A锁住了，所以用户B必须等到用户A释放表A才能访问。此时死锁就已经产生了。</p></li></ol><h2 id="JVM锁实现"><a href="#JVM锁实现" class="headerlink" title="JVM锁实现"></a>JVM锁实现</h2><p>JVM 锁实现是指通过 JVM 提供的内置锁如 Lock 或者是 synchronized 来实现幂等性。使用 JVM 锁来实现幂等性的一般流程为：首先通过 Lock 对代码段进行加锁操作，然后再判断此订单是否已经被处理过，如果未处理则开启事务执行订单处理，处理完成之后提交事务并释放锁，执行流程如下图所示：<br><img src="https://img-blog.csdnimg.cn/e76fe0e5993d4a1a86d6ecf2c9df5317.png" alt="在这里插入图片描述"><br>JVM 锁存在的最大问题在于，它只能应用于单机环境，因为 Lock 本身为单机锁，所以它就不适应于分布式多机环境。</p><h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><p>分布式锁实现幂等性的逻辑是，在每次执行方法之前先判断是否可以获取到分布式锁，如果可以，则表示为第一次执行方法，否则直接舍弃请求即可，执行流程如下图所示：<br><img src="https://img-blog.csdnimg.cn/ed4724433a0d4467823facaa66adcc33.png" alt="在这里插入图片描述"><br>分布式锁存在的问题是</p><ol><li><p>锁续期问题</p><p> 当对业务进行加锁时，锁的过期时间，绝对不能想当然的设置一个值。假设线程A在执行某个业务时加锁成功并设置锁过期时间。但该业务执行时间过长，业务的执行时间超过了锁过期时间，那么在业务还没执行完时，锁就自动释放了。接着后续线程就可以获取到锁，又来执行该业务。就会造成线程A还没执行完，后续线程又来执行，导致同一个业务逻辑被重复执行。</p></li><li><p>服务单点&amp;集群问题</p><p> 在单点redis虽然可以完成锁操作，可一旦redis服务节点挂掉了，则无法提供锁操作。<br>在生产环境下，为了保证redis高可用，会采用异步复制方法进行主从部署。当主节点写入数据成功，会异步的将数据复制给从节点，并且当主节点宕机，从节点会被提升为主节点继续工作。假设主节点写入数据成功，在没有将数据复制给从节点时，主节点宕机。则会造成提升为主节点的从节点中是没有锁信息的，其他线程则又可以继续加锁，导致互斥失效。</p></li></ol><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;幂等的作用&quot;&gt;&lt;a href=&quot;#幂等的作用&quot; class=&quot;headerlink&quot; title=&quot;幂等的作用&quot;&gt;&lt;/a&gt;幂等的作用&lt;/h2&gt;&lt;p&gt;无论是单机或者分布式系统都会遇到并发的问题，除了使用类似流量控制等的方法之外，当请求真正到达后端服务器之后，幂等设计就可以作为一种解决方案了。&lt;/p&gt;
&lt;p&gt;基于消息队列的分布式架构的系统中，由于各种原因，比如网络波动等，队列里面的消息就会重发，从本质上来说，系统自动产生了一个并发请求。简单一点也可以理解为一个webapi接口被完全“相同”的参数调用了多次，这时候幂等就派上用处了。&lt;/p&gt;</summary>
    
    
    
    <category term="Java学习" scheme="http://cmblogs.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="http://cmblogs.cn/tags/Java/"/>
    
    <category term="分布式" scheme="http://cmblogs.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="幂等" scheme="http://cmblogs.cn/tags/%E5%B9%82%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习</title>
    <link href="http://cmblogs.cn/2021/11/18/Docker%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://cmblogs.cn/2021/11/18/Docker%E5%AD%A6%E4%B9%A0.html</id>
    <published>2021-11-18T12:26:30.000Z</published>
    <updated>2021-11-23T16:08:31.001Z</updated>
    
    <content type="html"><![CDATA[<p><code>参考文章：</code><a href="https://yeasy.gitbook.io/docker_practice/">Docker-从入门到实践</a></p><p><strong>服务器虚拟化解决的核心问题是资源调配，而容器解决的核心问题是应用开发、测试和部署。</strong></p><h2 id="一、Docker是什么"><a href="#一、Docker是什么" class="headerlink" title="一、Docker是什么"></a>一、Docker是什么</h2><p>Docker是一种轻量级的操作系统虚拟化解决方案，它想达到一次构建到处运行，类似于Java虚拟机的效果，它最初诞生于2013年，是基于go语言的实现，最初是由dotCloud公司的内部一个业余项目，后来项目开源加入了Linux基金会，然后现在代码在github上进行维护。Docker的基础是基于Linux容器技术，在Linux容器技术的基础上，Docker进行了进一步的封装，让大家不去关心容器的管理，使得操作更加便捷。用户操作Docker容器，就像操作一个快速轻量级的虚拟机那样简单。</p><span id="more"></span><br/><h2 id="二、Docker和虚拟机的区别"><a href="#二、Docker和虚拟机的区别" class="headerlink" title="二、Docker和虚拟机的区别"></a>二、Docker和虚拟机的区别</h2><p><code>参考文章</code> : <a href="https://www.zhihu.com/question/48174633/answer/568562893">Docker和虚拟机的区别</a></p><img src="https://pica.zhimg.com/50/v2-e30ef11428ac454d101f2b7d3ffc067e_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="595" data-rawheight="370" class="origin_image zh-lightbox-thumb" width="595" data-original="https://pic3.zhimg.com/v2-e30ef11428ac454d101f2b7d3ffc067e_r.jpg?source=1940ef5c"/><p>从结构上来看，容器和虚拟机还是有很大不同的。</p><p>左图的虚拟机的Guest层，还有Hypervisor层在Docker上已经被Docker Engine层所取代，在这里我们需要知道，Guest OS 是虚拟机安装的操作系统，是一个完整的系统内核，另外Hypervisor可以理解为硬件虚拟化平台，它在后Host OS以内核驱动的形式存在。</p><p>虚拟机实现资源的隔离的方式是利用独立的Guest OS，以及利用Hypervisor虚拟化CPU、内存、IO等设备来实现的，对于虚拟机实现资源和环境隔离的方案，Docker显然简单很多。</p><p>Docker 底层的核心技术包括 Linux 上的命名空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。简单来说，Docker就是利用Namespace 实现了系统环境的隔离，利用了cgroup实现了资源的限制，利用镜像实例实现跟环境的隔离。</p><p>Docker有着比虚拟机更少的抽象层。由于Docker不需要Hypervisor实现硬件资源的虚拟化，所以运行在Docker容器上的程序，直接使用的都是实际物理机的硬件资源。因此在cpu、内存、利用率上，Docker将会在效率上具有更大的优势。此外，Docker直接利用虚拟机机的系统内核，避免了虚拟机启动时所需要的系统引导时间和操作系统运行的资源消耗，利用Docker能够在几秒钟之内启动大量的容器，是虚拟机无法办到的。快速启动低资源消耗的优点，使Docker在弹性云平台自动运维系统方面具有很好的应用场景。</p><p>与虚拟机相比，Docker在以下几个方面具有很大的优势，它能够快速的交付和部署，Docker在整个开发周期都可以完美辅助你实现快速交付，Docker允许开发者本地应用，直接进入到可持续的开发流程中。例如开发者可以使用一个标准镜像构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码，Docker可以快速创建容器快速迭代应用程序，整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。</p><p>此外，容器的启动时间是秒级的，大量节约开发、测试、部署的时间。还有一个非常关键的点，就是Docker能够高效地部署和扩容，Docker容器几乎可以在任意平台上运行，包括虚拟机、物理机、公有云、私有云、个人电脑、服务器等，这种兼容性，可以让用户把一个应用程序从一个平台直接迁移到另外一个平台。Docker的兼容性和轻量性的特性可以轻松的实现负载的动态管理，你可以快速扩容或方便的下线你的应用和服务，这种速度趋近于实时！此外Docker还具有更高的资源利用率，一台主机上可以运行数千个Docker容器，容器除了运行其应用之外，基本不消耗额外的系统资源，使得应用性能高，系统开销小。</p><p>而传统的虚拟机方式则需要运行不同的应用，耗费大量的资源，此外Docker还可以有更简单的管理使用Docker只需要小小的修改就可以替代以往大量的更新工作，所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</p><br/><h2 id="三、通过Docker启动Mysql"><a href="#三、通过Docker启动Mysql" class="headerlink" title="三、通过Docker启动Mysql"></a>三、通过Docker启动Mysql</h2><p>Docker的命令组成为<code>Docker + 动作 + 命令 + 镜像</code></p><ol><li><p>搜索镜像<br><code>docker search mysql</code></p><p>ps：这里有个坑，解决了但不知道原因<br>在登陆状态下search镜像会报错<br><img src="https://img-blog.csdnimg.cn/552bc6da23b040fe973224f171ba4c02.png" alt="在这里插入图片描述"><br>但是logout之后就可以正常search和pull了…</p></li><li><p>拉取镜像<br><code>docker pull mysql</code></p></li><li><p>启动镜像<br><code>docker run -dit --name mysql -e MYSQL_ROOT_PASSWORD=root mysql</code></p><p>这里各个-命令的意思：<br><code>-d:</code> 在后台运行容器，并且打印容器id。<br><code>-i:</code> 即使没有连接，也要保持标准输入保持打开状态，一般与 -t 连用。<br><code>-t:</code> 分配一个伪tty，一般与 -i 连用。<br><code>--name:</code> 给容器赋予一个name，后续命令除了使用容器id还可以使用name指定容器<br><code>-e MYSQL_ROOT_PASSWORD=root :</code> 初始化root用户的密码<br><code>-p 3306:3306:</code> 表示这个容器中使用3306（第二个）映射到本机的端口号也为3306（第一个） </p></li><li><p>进入Mysql<br>先进入容器： <code>docker exec -it mysql bash</code><br>登陆Mysql：<code>mysql -u root -p</code> 输入密码<br>成功：<br><img src="https://img-blog.csdnimg.cn/725360704bc64178883e485ecf9ee4ca.png" alt="在这里插入图片描述"></p></li></ol><br/><h2 id="四、容器间互相访问"><a href="#四、容器间互相访问" class="headerlink" title="四、容器间互相访问"></a>四、容器间互相访问</h2><ol><li><p>通过 <code>--link</code> 连接容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如使用xxl-job连接容器中的mysql5.7</span></span><br><span class="line">docker run ... --link mysql_5.7:mysql ...</span><br><span class="line"><span class="comment"># --link mysql容器名：mysql容器在xxl-job容器中的映射名</span></span><br><span class="line">-&gt; 注意：建立映射名后配置文件中的地址应直接改为映射名，比如下方的mysql连接 &lt;-</span><br><span class="line">-e PARAMS=<span class="string">&quot;--spring.datasource.url=jdbc:mysql://mysql:3306/xxl_job&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>通过 <code>--network</code> 创建一个Bridge网络，在run容器时指定该网络即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network create mynet  <span class="comment"># 创建网络</span></span><br><span class="line">docker run -dit --name redis --network mynet -p 10087:6379 redis  <span class="comment"># 创建redis容器</span></span><br><span class="line"><span class="comment"># 创建mysql容器</span></span><br><span class="line">docker run -dit --name mysql --network mynet -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入redis容器看看能不能ping通mysql</span></span><br><span class="line">docker <span class="built_in">exec</span> -it redis bash</span><br></pre></td></tr></table></figure><p>此时执行ping命令，出现 <code>bash: ping: command not found</code><br><img src="https://img-blog.csdnimg.cn/c12008a786574e218ca3332daaa9640d.png" alt="在这里插入图片描述"><br>百度后通过 <code>apt-get update</code> + <code>apt-get install iputils-ping</code> 解决问题，解决问题后再ping就可以ping通了<br><img src="https://img-blog.csdnimg.cn/6d8ca66fa6db4761bae1c62752bb9f72.png" alt="在这里插入图片描述"></p></li><li><p>通过虚拟IP访问<br>安装docker时，docker会默认创建一个内部的桥接网络docker0，每创建一个容器分配一个虚拟网卡，容器之间可以根据ip互相访问。</p><p>使用 <code>ifconfig</code> 命令出现 <code>bash: ifconfig: command not found</code><br><img src="https://img-blog.csdnimg.cn/04a0d7bec55c46f483d526076b425b89.png" alt="在这里插入图片描述"><br>解决：<code>apt install net-tools</code>，解决后使用 <code>ifconfig</code> 看到如下：<br><img src="https://img-blog.csdnimg.cn/24ba3b3a36d641509f6bb0c440cddecf.png" alt="在这里插入图片描述"><br>redis 容器中我们得到的 ip地址是 172.18.0.2，然后进入mysql容器去ping一下redis</p><p>在没使用虚拟IP之前先ping一次，可以看到无法ping通<br><img src="https://img-blog.csdnimg.cn/bdf0b2b8f21a4139a46c0de142a06648.png" alt="在这里插入图片描述"><br>再ping一下虚拟IP：<br><img src="https://img-blog.csdnimg.cn/cca7107da08d490abd322c8e0ab0c16d.png" alt="在这里插入图片描述"><br>没ping通？？使用2中同一个Bridge网络的mysql来ping这个redis可以ping通：<br><img src="https://img-blog.csdnimg.cn/9f5e720a6207426fb672108c26d8d4ea.png" alt="在这里插入图片描述"><br><strong>排查：</strong><br>运行 <code>docker network inspect bridge</code> ，可以看到处于docker0网络的只有mysql_5.7这一个容器！才想起来我使用的是已经指定了network的redis，所以可能并没有被分配到默认的docker0中。<br><img src="https://img-blog.csdnimg.cn/c8483b90305843edb7310370ecc21ed2.png" alt="在这里插入图片描述"><br>运行 <code>docker network connect bridge redis</code> 后，再查看docker0中的容器：<br><img src="https://img-blog.csdnimg.cn/b0c2e55e87d04c819c4ee17126ba3b76.png" alt="在这里插入图片描述"><br>再进入mysql中ping一下redis，发现还是ping不通！</p><p>进入redis中查看 <code>ifconfig</code>：<br><img src="https://img-blog.csdnimg.cn/a391bd9e45b74074bd377519d9366225.png" alt="在这里插入图片描述"><br>发现出现了两个虚拟IP地址，反应过来应该是每一个网络都会给容器分配一个不同的虚拟ip地址，原来我一直ping的都是2中mynet给redis分配的地址，人麻了…</p><p>在redis里再ping这个mysql，终于通了！<br><img src="https://img-blog.csdnimg.cn/6109b28132234860aac8f014eb5ea5a5.png" alt="在这里插入图片描述"></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;参考文章：&lt;/code&gt;&lt;a href=&quot;https://yeasy.gitbook.io/docker_practice/&quot;&gt;Docker-从入门到实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器虚拟化解决的核心问题是资源调配，而容器解决的核心问题是应用开发、测试和部署。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、Docker是什么&quot;&gt;&lt;a href=&quot;#一、Docker是什么&quot; class=&quot;headerlink&quot; title=&quot;一、Docker是什么&quot;&gt;&lt;/a&gt;一、Docker是什么&lt;/h2&gt;&lt;p&gt;Docker是一种轻量级的操作系统虚拟化解决方案，它想达到一次构建到处运行，类似于Java虚拟机的效果，它最初诞生于2013年，是基于go语言的实现，最初是由dotCloud公司的内部一个业余项目，后来项目开源加入了Linux基金会，然后现在代码在github上进行维护。Docker的基础是基于Linux容器技术，在Linux容器技术的基础上，Docker进行了进一步的封装，让大家不去关心容器的管理，使得操作更加便捷。用户操作Docker容器，就像操作一个快速轻量级的虚拟机那样简单。&lt;/p&gt;</summary>
    
    
    
    <category term="Java学习" scheme="http://cmblogs.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="http://cmblogs.cn/tags/Java/"/>
    
    <category term="Docker" scheme="http://cmblogs.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》 — 学习笔记</title>
    <link href="http://cmblogs.cn/2021/10/14/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%20%E2%80%94%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://cmblogs.cn/2021/10/14/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%20%E2%80%94%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</id>
    <published>2021-10-14T05:46:25.000Z</published>
    <updated>2021-12-13T17:03:07.506Z</updated>
    
    <content type="html"><![CDATA[<p><code>参考资料：</code></p><p>深入理解JAVA虚拟机（第三版）_JVM高级特性与最佳实践—周志明</p><p><a href="https://ezlippi.com/blog/2018/01/safepoint.html">JVM安全点介绍</a></p><hr><h2 id="根节点枚举STW"><a href="#根节点枚举STW" class="headerlink" title="根节点枚举STW"></a>根节点枚举STW</h2><p>迄今为止，所有收集器在GC Root根节点枚举这一步骤时都是<strong>必须暂停用户线程</strong>的，因此毫无疑问根节点枚举与整理内存碎片一样会<strong>面临相似的“Stop The World”的困扰</strong>。</p><p>现在可达性分析算法耗时最长的查找引用链的过程已经可以与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行（不会出现分析过程中根节点集合的对象引用关系还在不断变化的情况）</p><hr><span id="more"></span><h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>安全点就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比如GC.<br>这些特定的位置主要有几下几种:</p><ol><li>方法返回之前</li><li>调用某个方法之后</li><li>抛出异常的位置</li><li>循环的末尾</li></ol><p><strong><code>safepoint的使用场景</code></strong></p><ol><li> 垃圾回收(这是最常见的场景)</li><li> 取消偏向锁(JVM会使用偏向锁来优化锁的获取过程)</li><li> Class重定义(比如常见的hotswap和instrumentation)</li><li> Code Cache Flushing(JDK1.8在CodeCache满的情况下就可能出现)</li><li> 线程堆栈转储(jstack命令)</li></ol><p> 对于安全点，另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程（这里其实不包括执行 JNI 调用的线程）都跑到最近的安全点，然后停顿下来。这里有两种方案可供选择：<code>抢先式中断（ Preemptive Suspension ）和主动式中断（ Voluntary Suspension ）</code>，抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应 GC 事件。</p><p>而主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，<strong>仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起</strong>。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在 Java 堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</p><hr><h2 id="记忆集与卡表、写屏障"><a href="#记忆集与卡表、写屏障" class="headerlink" title="记忆集与卡表、写屏障"></a>记忆集与卡表、写屏障</h2><p>讲解分代收集理论的时候，提到了为解决对象跨代引用所带来的问题，<strong>垃圾收集器在新生代中建立了名为记忆集（ Remembered Set ）的数据结构，用以避免把整个老年代加进 GC Roots 扫描范围</strong>。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（ Partial GC ）行为的垃圾收集器，典型的如 G1 、 ZGC 和 Shenandoah 收集器，都会面临相同的问题，因此我们有必要进一步理清记忆集的原理和实现方式，以便在后续章节里介绍几款最新的收集器相关知识时能更好地理解。</p><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。如果我们不考虑效率和成本的话，==最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构==。</p><p>下面列举了一些可供选择的记录精度：</p><ol><li><code>字节精度：</code></li><li><code>对象精度：</code></li><li><code>卡精度：</code></li></ol><p>其中，第三种“卡精度”所指的是用一种称为卡表的方式去实现记忆集，这也是目前最常用的一种记忆集实现形式。</p><p><code>写屏障：可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面</code></p><hr><h2 id="并发可达性分析—三色标记"><a href="#并发可达性分析—三色标记" class="headerlink" title="并发可达性分析—三色标记"></a>并发可达性分析—三色标记</h2><ul><li><p>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</p></li><li><p>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</p></li><li><p>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</p></li></ul><p>并发出现“对象消失”问题示意：<br><img src="https://img-blog.csdnimg.cn/20210715153458604.jpg"><br>Wilson 于 1994 年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：</p><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ul><p>因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：<strong>增量更新（ Incremental Update ）和原始快照（ Snapshot At The Beginning ， SATB ）</strong>。</p><p>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。<code>这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</code></p><p>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。<code>这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</code></p><p>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在 HotSpot 虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如， <strong>CMS 是基于增量更新来做并发标记的， G1 、 Shenandoah 则是用原始快照来实现。</strong></p><hr><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><code>并行（ Parallel ）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。</code><br><code>并发（ Concurrent ）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。</code></p><h3 id="Serial（串行）收集器"><a href="#Serial（串行）收集器" class="headerlink" title="Serial（串行）收集器"></a>Serial（串行）收集器</h3><p>单线程工作的收集器，<strong>但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作</strong>，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直至它收集结束。</p><p>Serial + Serial Old：<br><img src="https://img-blog.csdnimg.cn/20210715163223461.jpg" alt="在这里插入图片描述"></p><br/><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器实质上是Serial收集器的多线程并行版本，<strong>除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处</strong>，但它确实不少运行在服务端模式夏的HotSpot虚拟机，尤其是JDK7之前的遗留系统中首选的新生代收集器，其中<strong>有一个重要原因是除了Serial收集器外，目前只有它能与CMS收集器配合工作。</strong></p><br/><h3 id="Parallel-Scavenge收集器（吞吐量优先收集器）"><a href="#Parallel-Scavenge收集器（吞吐量优先收集器）" class="headerlink" title="Parallel Scavenge收集器（吞吐量优先收集器）"></a>Parallel Scavenge收集器（吞吐量优先收集器）</h3><p>Parallel Scavenge收集器也是一款新生代收集器，同样是基于标记-复制算法实现，也是能够并行收集的多线程收集器，这些特性跟ParNew非常相似，但它的特别之处在于它的关注点与其他收集器不同，==CMS等收集器的关注点是尽可能缩短STW的时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量==。<br><img src="https://img-blog.csdnimg.cn/20210715163336303.jpg" alt="在这里插入图片描述"></p><br/><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记 - 整理算法。这个收集器的主要意义也是供客户端模式下的 HotSpot 虚拟机使用。</p><p>如果在服务端模式下，它也可能有两种用途：一种是在 JDK 5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用  ，另外一种就是作为 CMS 收集器发生失败时的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</p><br/><h3 id="Parllel-Old收集器"><a href="#Parllel-Old收集器" class="headerlink" title="Parllel Old收集器"></a>Parllel Old收集器</h3><p>Parllel Old收集器是Parallel Scavenge收集器的老年代版本，基于标记-整理算法实现。</p><p>==在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge + Parallel Old收集器这个组合==</p><p>Parallel Scavenge + Parallel Old：<br><img src="https://img-blog.csdnimg.cn/20210715163604525.jpg" alt="在这里插入图片描述"></p><h3 id="CMS（Concurrent-Mark-Sweep）收集器"><a href="#CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Concurrent Mark Sweep）收集器"></a>CMS（Concurrent Mark Sweep）收集器</h3><p>CMS 收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网网站或者基于浏览器的 B/S 系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。 CMS 收集器就非常符合这类应用的需求。</p><p>从名字（包含“Mark Sweep” ）上就可以看出 CMS 收集器是基于标记 - 清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：</p><ol><li><font color = red>初始标记</font></li><li>并发标记</li><li><font color = red>重新标记</font></li><li>并发清除</li></ol><p>其中初始和重新标记这两个步骤仍然需要STW，==初始标记仅仅是标记一下GC Roots能直接关联到的对象，速度很快==；<strong>并发标记阶段</strong>（<strong>并发可达性分析</strong>）就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；<strong>而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（增量更新）</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，<strong>由于不需要移动存活对象（产生内存碎片）</strong>，所以这个阶段也是可以与用户线程同时并发的。</p><p><img src="https://img-blog.csdnimg.cn/20210715165142945.jpg" alt="在这里插入图片描述"><br><strong>CMS不足之处：</strong></p><ol><li><strong>会产生空间碎片：</strong> 既然CMS是基于标记清除算法实现的，那就无法避免产生不连续的内存空间（空间碎片）</li><li><strong>无法处理浮动垃圾：</strong> 在 CMS 的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后， CMS 无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。</li></ol><br/><h3 id="Garbage-First（G1）收集器"><a href="#Garbage-First（G1）收集器" class="headerlink" title="Garbage First（G1）收集器"></a>Garbage First（G1）收集器</h3><p>==Garbage First 收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于 Region 的内存布局形式。==</p><p>在 G1 收集器出现之前的所有其他收集器，包括 CMS 在内，垃圾收集的目标范围要么是整个新生代（ Minor GC ），要么就是整个老年代（ Major GC ），再要么就是整个 Java 堆（ Full GC ）。而 G1 跳出了这个樊笼，它可以<strong>面向堆内存任何部分来组成回收集（ Collection Set ，一般简称 CSet ）</strong> 进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，<strong>这就是 G1 收集器的 Mixed GC 模式</strong>。 </p><p>G1 开创的基于 Region 的堆内存布局是它能够实现这个目标的关键。虽然 G1 也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异： G1 不再坚持固定大小以及固定数量的分代区域划分，而是<strong>把连续的 Java 堆划分为多个大小相等的独立区域（ Region ）</strong>，每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、 Survivor 空间，或者老年代空间。收集器能够对扮演不同角色的 Region 采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p><p>Region 中还有一类特殊的 <strong>Humongous</strong> 区域，专门用来存储大对象。 G1 认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象。而对于那些超过了整个 Region 容量的超级大对象，将会被存放在 <strong>N 个连续的 Humongous Region</strong> 之中， G1 的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待</p><p>==G1 收集器之所以能建立可预测的停顿时间模型，是因为它将 Region 作为单次回收的最小单元，即每次收集到的内存空间都是 Region 大小的整数倍，这样可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。==</p><p>更具体的处理思路是让 G1 收集器去跟踪各个 Region 里面的<strong>垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值</strong>，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数 -XX ： MaxGCPauseMillis 指定，默认值是 200 毫秒），优先处理回收价值收益最大的那些 Region ，这也就是“Garbage First” 名字的由来。这种使用 Region 划分内存空间，以及具有优先级的区域回收方式，<strong>保证了 G1 收集器在有限的时间内获取尽可能高的收集效率</strong>。<br><img src="https://img-blog.csdnimg.cn/20210715231914898.jpg" alt="在这里插入图片描述"><br><code>需要解决的细节问题:</code></p><p>Q：Region 里面存在的跨 Region 引用对象如何解决？</p><p>解决的思路我们已经知道：使用记忆集避免全堆作为 GC Roots 扫描，但在 G1 收集器上记忆集的应用其实要复杂很多，==它的每个 Region 都维护有自己的记忆集==，这些记忆集会记录下别的 Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。<strong>G1 的记忆集在存储结构的本质上是一种哈希表， Key 是别的 Region 的起始地址， Value 是一个集合，里面存储的元素是卡表的索引号。</strong> 这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于 Region 数量比传统收集器的分代数量明显要多得多，因此 G1 收集器要比其他的传统垃圾收集器有着更高的内存占用负担。根据经验， <strong>G1 至少要耗费大约相当于 Java 堆容量 10% 至 20% 的额外内存来维持收集器工作</strong>。</p><p>Q：如何保证并发可达性分析？</p><p>CMS通过增量更新，G1通过原始快照。此外，垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建， <strong>G1 为每一个 Region 设计了两个名为 TAMS （ Top at Mark Start ）的指针，把 Region 中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。 G1 收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。</strong></p><p>==G1收集器的运作过程大致可划分为以下四个步骤：==</p><ol><li>初始标记（ Initial Marking ）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行 Minor GC 的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿。</li><li>并发标记（ Concurrent Marking ）：从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理 SATB 记录下的在并发时有引用变动的对象。 </li><li>最终标记（ Final Marking ）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。 </li><li>筛选回收（ Live Data Counting and Evacuation ）：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。<br><img src="https://img-blog.csdnimg.cn/20210716151525304.jpg" alt="在这里插入图片描述"></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;参考资料：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;深入理解JAVA虚拟机（第三版）_JVM高级特性与最佳实践—周志明&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ezlippi.com/blog/2018/01/safepoint.html&quot;&gt;JVM安全点介绍&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;根节点枚举STW&quot;&gt;&lt;a href=&quot;#根节点枚举STW&quot; class=&quot;headerlink&quot; title=&quot;根节点枚举STW&quot;&gt;&lt;/a&gt;根节点枚举STW&lt;/h2&gt;&lt;p&gt;迄今为止，所有收集器在GC Root根节点枚举这一步骤时都是&lt;strong&gt;必须暂停用户线程&lt;/strong&gt;的，因此毫无疑问根节点枚举与整理内存碎片一样会&lt;strong&gt;面临相似的“Stop The World”的困扰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在可达性分析算法耗时最长的查找引用链的过程已经可以与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行（不会出现分析过程中根节点集合的对象引用关系还在不断变化的情况）&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="学习记录" scheme="http://cmblogs.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JVM" scheme="http://cmblogs.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习</title>
    <link href="http://cmblogs.cn/2021/09/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://cmblogs.cn/2021/09/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0.html</id>
    <published>2021-09-15T08:50:05.000Z</published>
    <updated>2021-12-13T17:03:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-网络分层模型"><a href="#1-网络分层模型" class="headerlink" title="1. 网络分层模型"></a>1. 网络分层模型</h2><ul><li><p><strong>OSI七层模型</strong></p><p>  <strong>应用层</strong><br>  网络服务与最终用户的一个接口。<br>  协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</p><p>  <strong>表示层</strong><br>  数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）<br>  格式有，JPEG、ASCll、EBCDIC、加密格式等</p><p>  <strong>会话层</strong><br>  建立、管理、终止会话。（在五层模型里面已经合并到了应用层）<br>  对应主机进程，指本地主机与远程主机正在进行的会话</p><p>  <strong>传输层</strong><br>  定义传输数据的协议端口号，以及流控和差错校验。<br>  协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层</p><p>  <strong>网络层</strong><br>  进行逻辑地址寻址，实现不同网络之间的路径选择。<br>  协议有：ICMP IGMP IP（IPV4 IPV6）</p><p>  <strong>数据链路层</strong><br>  建立逻辑连接、进行硬件地址寻址、差错校验 [3]  等功能。（由底层网络定义协议）<br>  将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p><p>  <strong>物理层</strong><br>  建立、维护、断开物理连接。（由底层网络定义协议）</p>  <span id="more"></span></li></ul><ul><li><p><strong>TCP/IP 四层模型</strong></p><p>  <strong>应用层</strong></p><p>  <strong>运输层</strong></p><p>  <strong>网络层</strong></p><p>  <strong>数据链路层</strong></p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210418093058230.png" alt="在这里插入图片描述"></p><hr><h2 id="2-三握四挥"><a href="#2-三握四挥" class="headerlink" title="2. 三握四挥"></a>2. 三握四挥</h2><p><img src="https://img-blog.csdnimg.cn/20210416165542507.png" alt="在这里插入图片描述"></p><ul><li><p><strong><font color = #E579B6> 为什么要握手</font></strong><br>  为了保证可靠性传输，TCP需要两边维护socket，序列号，和窗口大小（流量控制用），握手就是为了在数据开始传输前让客户端和服务器准确无误的交换上述信息。</p><p>  需要握手的原因：</p><ol><li>阻止已经失效的历史请求的初始化【谢希仁】</li><li>只有通过三次握手才能交换序列号</li></ol></li><li><p><strong><font color = #E579B6> 为什么要三次握手</font></strong></p><p>  因为第一二次握手只是让客户端知道了客户端发送的请求服务器端可以收到，服务器端发送的请求客户端自己也能收到，但是对服务器端来说，它只知道客户端发送的请求自己能收到，但是自己发送的请求不知道客户端能不能收到，所以需要第三次握手来让服务器端知道，这也是建立连接需要的最少次数。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210416165558640.png" alt="在这里插入图片描述"></p><ul><li><p><strong><font color = #E579B6> 为什么是三握四挥而不是四握四挥</font></strong></p><p>  因为TCP建立连接时之所以只需要”三次握手”，是因为在第二次”握手”过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。<strong>SYN是请求连接标志</strong>，表示服务器端同意建立连接；<strong>ACK是确认报文</strong>，表示告诉客户端，服务器端收到了它的请求报文。</p><p>  即与挥手相比，第二次握手的时候<strong>服务器端将确认接收报文和请求连接报文合在一起发给了客户端</strong>，所以相比四挥少了一次。</p><p>  建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段<strong>并不需要任何准备，可以直接返回SYN和ACK报文</strong>，开始建立连接。</p><p>  释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时<strong>并不能立即释放连接</strong>，因为还有必要的数据需要处理，所以服务器<strong>先返回ACK确认收到报文</strong>，经过<strong>CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文</strong>。</p></li></ul><br/><ul><li><p><strong>为什么客户端在TIME-WAIT阶段要等2MSL</strong></p><p>  为的是确认服务器端是否收到客户端发出的ACK确认报文</p><p>  当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。</p><p>  MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。<strong>2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长</strong>。</p><p>  如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，<strong>重新开始2MSL的计时</strong>；<br>否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，<strong>完成“四次挥手”</strong></p></li></ul><hr><h2 id="3-ICMP协议的应用"><a href="#3-ICMP协议的应用" class="headerlink" title="3.  ICMP协议的应用"></a>3.  ICMP协议的应用</h2><p><a href="https://www.cnblogs.com/Mrspe/articles/12335328.html">ICMP协议的应用</a></p><p><font color = #E579B6> ping命令和traceRoute:</font></p><p>tracert（traceroute）工具<br>tracert和traceroute是一样的意思，只是一个常用在华为设备上，一个用在思科设备上<br>可以跟踪网络中从源节点到目标节点中间所经过的所有三层节点信息</p><p>tracert（traceroute）和ping一样可以跟IP和域名<br><img src="https://img-blog.csdnimg.cn/20210421104500887.png" alt="在这里插入图片描述"><br>这两个工具常用于检查连通性和排查故障节点</p><hr><h2 id="4-TCP如何保证可靠性"><a href="#4-TCP如何保证可靠性" class="headerlink" title="4. TCP如何保证可靠性"></a>4. TCP如何保证可靠性</h2><p><a href="https://www.jianshu.com/p/de85547cd5de">TCP协议详解</a><br><strong>+</strong><br><font color = #E579B6> 校验和:</font></p><p>计算方式：在数据传输的过程中，将发送的数据段都当做一个<strong>16位的整数</strong>。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。<br>发送方：在发送数据之前计算检验和，并进行校验和的填充。<br>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行<strong>比对</strong>。<br><img src="https://img-blog.csdnimg.cn/20210421114104224.png" alt="在这里插入图片描述"><br>注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，<strong>数据不一定传输成功</strong>。</p><hr><h2 id="5-如何实现UDP的可靠传输"><a href="#5-如何实现UDP的可靠传输" class="headerlink" title="5. 如何实现UDP的可靠传输"></a>5. 如何实现UDP的可靠传输</h2><p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。</p><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是<strong>实现不在传输层</strong>，实现转<strong>移到了应用层</strong>。</p><p>最简单的方式是在<strong>应用层模仿传输层</strong>TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p><ol><li><p>添加seq/ack机制，确保数据发送到对端</p></li><li><p>添加发送和接收缓冲区，主要是用户超时重传。</p></li><li><p>添加超时重传机制。</p></li></ol><p>详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p><p>目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。</p><hr><h2 id="6-HTTPS的请求过程（SSL握手过程）"><a href="#6-HTTPS的请求过程（SSL握手过程）" class="headerlink" title="6. HTTPS的请求过程（SSL握手过程）"></a>6. HTTPS的请求过程（SSL握手过程）</h2><table><thead><tr><th>步骤</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td><strong>客户端 -&gt; 服务器</strong></td><td>Client Hello</td><td><strong>传输客户端支持的加密组合、SSL版本与随机数Random1</strong>（质数）</td></tr><tr><td><strong>服务器 -&gt; 客户端</strong></td><td>Server Hello</td><td><strong>选择客户端支持的加密方法与随机数Random2等</strong></td></tr><tr><td></td><td>Certificate</td><td>服务端将自己的<strong>证书下发</strong>给客户端，让客户<strong>验证自己的身份</strong>，客户端<strong>验证通过后取出证书中的公钥</strong></td></tr><tr><td></td><td>Server Key Exchange</td><td>RSA：不需要 <br> DHE / ECDHE：需要</td></tr><tr><td></td><td>Server Hello done</td><td>通知客户端 Server Hello 结束</td></tr><tr><td><strong>客户端 -&gt; 服务器</strong></td><td>Client Key Exchange</td><td>客户端验证通过的证书取出公钥，生成并利用公钥加密随机数：<strong>preMaster secret</strong>，将其发给服务端。服务端利用私钥解密获得随机数。<br> 至此，客户端与服务端都拥有三个随机数，双方根据约定的算法生成一个秘钥<strong>master secret</strong>。之后的数据传输都是用这个密钥进行加解密</td></tr><tr><td></td><td>Change Cipher Spec</td><td>客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥<strong>master　secret</strong>加密</td></tr><tr><td></td><td>Encrypted Handshake Message</td><td>代表了握手结束。客户端将握手消息等数据生成摘要再用<strong>master secret</strong>加密。<br> 服务端接收后解密，并验证数据。</td></tr><tr><td><strong>服务器 -&gt; 客户端</strong></td><td>Change Cipher Spec</td><td>同上</td></tr><tr><td></td><td>Encrypted Handshake Message</td><td></td></tr></tbody></table><p><strong>整个过程分为以下几步：</strong></p><ol><li><p>客户端浏览器发起往服务器的 <strong>443</strong> 端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。</p></li><li><p>服务器收到请求，选择浏览器支持的<strong>加密算法和哈希算法</strong>。</p></li><li><p>服务器下将数字证书返回给浏览器，这里的数字证书可以是向某个可靠机构申请的，也可以是自制的。</p></li></ol><p><em>（注释：证书包括以下这些内容：1. 证书序列号。2. 证书过期时间。3. 站点组织名。4. 站点DNS主机名。5. 站点公钥。6. 证书颁发者名。7. 证书签名。因为证书就是要给大家用的，所以不需要加密传输）</em></p><ol start="4"><li><p>浏览器进入数字证书认证环节，这一部分是浏览器内置的 TSL 完成的：</p><p> (1) 首先浏览器会从<strong>内置的证书列表</strong>中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是<strong>不可信任</strong>的。如果查到了对应的机构，则取出<strong>该机构颁发的公钥</strong>。</p><p> (2) 用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性（验证过程类似上面 Bob 和 Susan 的通信）。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。</p><p> (3) 浏览器生成一个<strong>随机数 R</strong>，并使用<strong>网站公钥</strong>对 R 进行加密</p></li><li><p>浏览器将加密的 R 传送给服务器。</p></li><li><p>服务器用自己的私钥解密得到 R。</p></li><li><p>服务器以 R 为密钥使用了对称加密算法加密网页内容并传输给浏览器，<br> 浏览器以 R 为密钥使用之前约定好的解密算法获取网页内容。</p></li></ol><hr><h2 id="7-输入网址到浏览器显示页面经历的过程"><a href="#7-输入网址到浏览器显示页面经历的过程" class="headerlink" title="7. 输入网址到浏览器显示页面经历的过程"></a>7. 输入网址到浏览器显示页面经历的过程</h2><ol><li><a href="https://blog.csdn.net/yanshuanche3765/article/details/82589210">DNS域名解析系统对输入的网址进行解析</a>    - 浏览器缓存 -&gt; 系统缓存(c盘/host) -&gt; 本地域名服务器(LDNS) -&gt; Root Server域名服务器</li></ol><pre><code>- DNS域名解析系统本质就是一个数据服务器，里面存储了域名和IP的对应关系- 最后会得到一个IP地址，通过这个IP地址，才能访问一台服务器- 得到一个地址后，就能知道我们要访问哪一台服务器了</code></pre><ol start="2"><li>客户端和服务端进行tcp的三次握手建立连接</li><li>客户端发送HTTP请求，服务端响应请求</li></ol><pre><code>- 客户端根据用户操作，如按下回车键，向服务器发送HTTP请求- 服务器接受请求，然后进行处理，整合需要的资源，通过HTTP协议传输响应发送给客户端浏览器</code></pre><ol start="4"><li>浏览器解析渲染页面</li><li>连接结束</li></ol><hr><h2 id="8-DNS协议用到了什么传输层协议？"><a href="#8-DNS协议用到了什么传输层协议？" class="headerlink" title="8. DNS协议用到了什么传输层协议？"></a>8. DNS协议用到了什么传输层协议？</h2><p><a href="https://www.cnblogs.com/wuyepeng/p/9835839.html">DNS用的是TCP协议还是UDP协议</a></p><p><strong>为什么既使用TCP又使用UDP？</strong> </p><p>首先了解一下TCP与UDP传送字节的长度限制：<br>UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。 </p><p>DNS占用<strong>53</strong>号端口，同时使用TCP和UDP协议。那么DNS在什么情况下使用这两种协议？</p><p>DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。</p><p><strong>区域传输的时候使用TCP协议</strong>：</p><ol><li><p>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</p></li><li><p>TCP是一种可靠连接，保证了数据的准确性。</p></li></ol><p><strong>域名解析时使用UDP协议</strong>：</p><p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p><hr><h2 id="9-HTTP、TCP、IP报文的结构"><a href="#9-HTTP、TCP、IP报文的结构" class="headerlink" title="9. HTTP、TCP、IP报文的结构"></a>9. HTTP、TCP、IP报文的结构</h2><br><p><strong>HTTP请求报文结构：</strong><br><img src="https://img-blog.csdnimg.cn/2021042517344319.png" alt="在这里插入图片描述"></p><p><strong>HTTP响应报文结构：</strong><br><img src="https://img-blog.csdnimg.cn/20210425173734406.png" alt="在这里插入图片描述"><br><strong>状态码说明：</strong></p><ul><li><p>1XX 请求正在处理</p></li><li><p>2XX 请求成功 </p><pre><code>200 OK 正常处理  204 no content 请求处理成功但没有资源可返回 206 Partial Content 对资源的某一部分请求</code></pre></li><li><p>3XX 重定向 </p><pre><code>301 Moved Permanenly请求资源的URI已经更新（永久移动），客户端会同步更新URI。302 Found 资源的URI已临时定位到其他位置，客户端不会更新URI。303 See Other 资源的URI已更新，明确表示客户端要使用GET方法获取资源。304 Not Modified 当客户端附带条件请求访问资源时资源已找到但未符合条件请求。307 Temporary Redirect临时重定向</code></pre></li><li><p>4XX 客户端错误 </p><pre><code>400 Bad Request 请求报文中存在语法错误，一般为参数异常。401 Unauthorized 发送的请求需要HTTP认证。403 Forbiddden 不允许访问，对请求资源的访问被服务器拒绝   404 Not Found 无法找到请求的资源，请求资源不存在。405 请求的方式不支持。</code></pre></li><li><p>5XX 服务器错误 </p><pre><code>500 Internal Server Error 服务器的内部资源出故障，服务器在执行请求时发生了错误。503 Service Unavailable 服务器暂时处于超负载状态或正在进行停机维护，无法处理请求，服务器正忙。</code></pre></li></ul><p><br><br></p><p><strong>TCP的报文结构：</strong><br><img src="https://img-blog.csdnimg.cn/20210425174424677.png" alt="在这里插入图片描述"></p><p><strong>IP的报文结构：</strong><br><img src="https://img-blog.csdnimg.cn/20210425174632528.png" alt="在这里插入图片描述"></p><hr><h2 id="10-Get、Post的区别"><a href="#10-Get、Post的区别" class="headerlink" title="10. Get、Post的区别"></a>10. Get、Post的区别</h2><p><a href="https://www.cnblogs.com/logsharing/p/8448446.html">GET和POST两种基本请求方法的区别</a></p><ol><li><p>GET参数通过<strong>URL</strong>传递，POST放在<strong>Request body</strong>中</p></li><li><p>GET在浏览器回退时是<strong>无害的（幂等）</strong>，而POST会<strong>再次提交请求（非幂等）</strong><br><code>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同</code></p></li><li><p>GET产生的URL地址可以被Bookmark，而POST不可以</p></li><li><p>GET请求会<strong>被浏览器主动cache</strong>，而POST不会，除非<strong>手动设置</strong></p></li><li><p>GET请求只能进行url编码，而POST支持多种编码方式</p></li><li><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</p></li><li><p>GET请求在URL中传送的参数是有<strong>长度限制</strong>的，而POST么有</p></li><li><p>对参数的数据类型，GET只接受<strong>ASCII</strong>字符，而POST没有限制</p></li><li><p>GET比POST更<strong>不安全</strong>，因为参数直接暴露在URL上，所以不能用来传递敏感信息</p></li></ol><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-网络分层模型&quot;&gt;&lt;a href=&quot;#1-网络分层模型&quot; class=&quot;headerlink&quot; title=&quot;1. 网络分层模型&quot;&gt;&lt;/a&gt;1. 网络分层模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;OSI七层模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;应用层&lt;/strong&gt;&lt;br&gt;  网络服务与最终用户的一个接口。&lt;br&gt;  协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;表示层&lt;/strong&gt;&lt;br&gt;  数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）&lt;br&gt;  格式有，JPEG、ASCll、EBCDIC、加密格式等&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;会话层&lt;/strong&gt;&lt;br&gt;  建立、管理、终止会话。（在五层模型里面已经合并到了应用层）&lt;br&gt;  对应主机进程，指本地主机与远程主机正在进行的会话&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;传输层&lt;/strong&gt;&lt;br&gt;  定义传输数据的协议端口号，以及流控和差错校验。&lt;br&gt;  协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;网络层&lt;/strong&gt;&lt;br&gt;  进行逻辑地址寻址，实现不同网络之间的路径选择。&lt;br&gt;  协议有：ICMP IGMP IP（IPV4 IPV6）&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;数据链路层&lt;/strong&gt;&lt;br&gt;  建立逻辑连接、进行硬件地址寻址、差错校验 [3]  等功能。（由底层网络定义协议）&lt;br&gt;  将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;物理层&lt;/strong&gt;&lt;br&gt;  建立、维护、断开物理连接。（由底层网络定义协议）&lt;/p&gt;</summary>
    
    
    
    <category term="学习记录" scheme="http://cmblogs.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="计网" scheme="http://cmblogs.cn/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>BIO、NIO、AIO 直接拿捏</title>
    <link href="http://cmblogs.cn/2021/08/10/IO%E6%A8%A1%E5%9E%8B.html"/>
    <id>http://cmblogs.cn/2021/08/10/IO%E6%A8%A1%E5%9E%8B.html</id>
    <published>2021-08-10T08:50:05.000Z</published>
    <updated>2021-12-13T17:03:17.933Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><font color = #E579B6> 从计算机的角度解读IO：</font></p><p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p><p><img src="https://img-blog.csdnimg.cn/20210424175005481.png" alt="在这里插入图片描述"><br><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p><br><span id="more"></span><p><font color = #E579B6> 从应用程序的角度来解读一下 I/O：</font></p><p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p><p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p><p>并且，用户空间的程序不能直接访问内核空间。</p><p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p><p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p><p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li><p>内核等待 I/O 设备准备好数据（内核缓冲区）</p></li><li><p>内核将数据从内核空间拷贝到用户空间</p></li></ol><br><p><font color = #E579B6> 常见的IO模型：</font></p><p>UNIX 系统下， IO 模型一共有 5 种：<strong>同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O</strong></p><hr><h2 id="BIO（同步阻塞IO）、NIO（同步非阻塞IO）、多路复用IO"><a href="#BIO（同步阻塞IO）、NIO（同步非阻塞IO）、多路复用IO" class="headerlink" title="BIO（同步阻塞IO）、NIO（同步非阻塞IO）、多路复用IO"></a>BIO（同步阻塞IO）、NIO（同步非阻塞IO）、多路复用IO</h2><p><font color = #E579B6> 1. 同步阻塞IO（BIO — Blocking I/O）:</font><br><img src="https://img-blog.csdnimg.cn/20210424174727357.png" alt="在这里插入图片描述"></p><p>阻塞IO情况下，当用户调用read后，用户线程会被<strong>阻塞</strong>（就是一直等待），等内核数据准备好并且数据从内核缓冲区拷贝到用户态缓存区后read才会返回。</p><br><p><font color = #E579B6> 2. 同步非阻塞IO:</font></p><p><img src="https://img-blog.csdnimg.cn/20210424180000754.png" alt="在这里插入图片描述"></p><p>非阻塞IO发出read请求后发现数据没准备好，会继续往下执行，此时应用程序会<strong>不断轮询</strong> polling内核询问数据是否准备好，当数据没有准备好时，内核立即返回EWOULDBLOCK错误。直到<strong>数据被拷贝到应用程序缓冲区</strong>，read请求才获取到结果。并且你要注意！这里最后一次 read 调用获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是<strong>内核态的数据拷贝到用户程序的缓存区</strong>这个过程。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：应用程序<strong>不断进行 I/O 系统调用轮询</strong>数据是否已经准备好的过程是<strong>十分消耗 CPU 资源的</strong>。</p><p>这时候 ， <strong>I/O 多路复用模型</strong> 就上场了。</p><p><img src="https://img-blog.csdnimg.cn/20210424215149143.png" alt="在这里插入图片描述"><br>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持<br><br><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。<br><br><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</p></blockquote><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的选择器 ( <strong>Selector</strong> ) 的概念，也可以被称为<strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><blockquote><p>Selector是JAVA NIO编程的基础。简单来讲，Selector会不断轮询注册在其上的channel，如果某个channel上面发生了读或者写事件，这个channel就会处于就绪状态，会被Selector轮询出来，然后通过selectorKey可以获取就绪channel的集合，进行后续的io操作。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210424215757602.png" alt="在这里插入图片描述"></p><hr><h2 id="AIO（异步IO）"><a href="#AIO（异步IO）" class="headerlink" title="AIO（异步IO）"></a>AIO（异步IO）</h2><p>同步跟异步的区别在于数据从内核空间拷贝到用户空间是否由用户线程完成，你会发现上面的提到过的操作都不是真正的异步，因为两个阶段总要等待会儿！而真正的异步 I/O 是内核数据准备好和数据从内核态拷贝到用户态这两个过程都不用等待。</p><p><img src="https://img-blog.csdnimg.cn/20210424221542715.png" alt="在这里插入图片描述"><br>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><strong>总结：</strong><br><img src="https://img-blog.csdnimg.cn/20210424221643460.png" alt="在这里插入图片描述"></p><hr><p>参考文章：</p><ol><li><a href="https://mp.weixin.qq.com/s/V8sndLDEjhbYMs8WN6svfA">京东数科二面：Java 中 BIO、NIO、AIO 的区别？</a></li><li><a href="https://www.jianshu.com/p/aab0f50846d0">阻塞、非阻塞、多路复用、同步、异步、BIO、NIO 一锅端</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h2&gt;&lt;p&gt;&lt;font color = #E579B6&gt; 从计算机的角度解读IO：&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210424175005481.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;&lt;strong&gt;从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;</summary>
    
    
    
    <category term="学习记录" scheme="http://cmblogs.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="IO" scheme="http://cmblogs.cn/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Spring请求分发机制</title>
    <link href="http://cmblogs.cn/2021/07/20/Spring%E8%AF%B7%E6%B1%82%E5%88%86%E5%8F%91.html"/>
    <id>http://cmblogs.cn/2021/07/20/Spring%E8%AF%B7%E6%B1%82%E5%88%86%E5%8F%91.html</id>
    <published>2021-07-20T12:59:10.000Z</published>
    <updated>2021-12-13T17:03:50.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-框架核心组件简介"><a href="#Spring-框架核心组件简介" class="headerlink" title="Spring 框架核心组件简介"></a>Spring 框架核心组件简介</h2><p><font color = #E579B6> 注解：</font></p><p>我们在使用 Spring 时接触最多的就是各种注解，包括：<br>@Component<br>（把普通pojo实例化到spring容器中，相当于配置文件中的<font color = red> &lt; bean id = “” class = “” /&gt; </font>）<br>@Controller、@Service、@Repository 等，这些都是 Spring 的核心组件。</p><span id="more"></span><p>除此之外，我们还会使用<br>@RequestMapping</p><blockquote><p>（在Spring MVC 中使用 @RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求，相当于Servlet中在web.xml中配置 **&lt; servlet &gt; +  &lt; servlet-mapping &gt;**）</p></blockquote><p>@<a href="https://blog.csdn.net/sswqzx/article/details/84195043">RequestParam</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**<span class="meta">@RequestParam</span>：将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）**</span><br><span class="line"></span><br><span class="line">语法：<span class="meta">@RequestParam(value=”参数名”,required=”true/false”,defaultValue=””)</span></span><br><span class="line"> </span><br><span class="line">value：参数名</span><br><span class="line"> </span><br><span class="line">required：是否包含该参数，默认为<span class="keyword">true</span>，表示该请求路径中必须包含该参数，如果不包含就报错。</span><br><span class="line"> </span><br><span class="line">defaultValue：默认参数值，如果设置了该值，required = <span class="keyword">true</span> 将失效，自动为<span class="keyword">false</span>,如果没有传该参数，就使用默认值</span><br></pre></td></tr></table></figure><p>@<a href="https://blog.csdn.net/sswqzx/article/details/84194979">PathVariable</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PathVariable(&quot;xxx&quot;)</span></span><br><span class="line">通过 <span class="meta">@PathVariable</span> 可以将URL中占位符参数&#123;xxx&#125;绑定到处理器类的方法形参中<span class="meta">@PathVariable(“xxx“)</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@RequestMapping(value=”user/&#123;id&#125;/&#123;name&#125;”)</span></span><br><span class="line">请求路径：http:<span class="comment">//localhost:8080/user/1/james</span></span><br></pre></td></tr></table></figure><p>@<a href="https://www.cnblogs.com/zly123/p/10853049.html">RequestBody</a> </p><p>主要用来接收前端传递给后端的<strong>json字符串中的数据</strong>(请求体中的数据)<br><strong>和RequestParam的区别：</strong><br>一个请求 -&gt; 只有一个@RequestBody；</p><p>一个请求 -&gt; 可以有多个@RequestParam。</p><p><br><br></p><p><font color = #E579B6> 框架模型：</font></p><p><a href="https://www.cnblogs.com/itlaobingge/p/11963351.html">Spring 框架处理 HTTP 请求的详细流程</a></p><ul><li><p>模型 Model：封装了业务数据，主要以 POJO 形式存在。</p></li><li><p>控制器 Controller：主要负责具体业务流程的调度控制，以及调用业务逻辑服务 Service。 控制器 Controller 处理完 HTTP 请求之后返回 ModelAndView 对象给前置分发器 DispatcherServlet，ModelAndView 中包含了模型 Model 对象和视图 View 名称。</p></li><li><p>视图 View：负责渲染呈现模型 Model 数据，以及提供表单供用户录入各种业务数据。</p></li><li><p>视图解析器 ViewResolver：负责根据已知的视图名称获取一个特定视图 View 子类实例对象。</p></li><li><p>处理器映射 HandlerMapping：主要负责控制器 Controller 的注册和查找，由应用上下文 ApplicationContext 持有。具体实现上它拥有 HashMap&lt;String, Object&gt; 类型的成员属性 handlerMap，其中 key 是 HTTP 请求的 URI 信息，value 可以是一个字符串或者处理请求的 HandlerExecutionChain。如果是 String，则视为 Spring Bean 名称。</p></li><li><p>服务 Service：主要负责实现具体的业务逻辑。</p></li><li><p>数据存储对象 Repository：也称为数据访问对象 DAO（Data Access Object），不管采用什么开发框架，大部分应用都需要跟数据库交互，DAO 就是将访问数据库操作做了封装，隔离了 SQL 相关复杂度。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210424205757733.png" alt="在这里插入图片描述"></p><hr><h2 id="Spring的请求分发机制"><a href="#Spring的请求分发机制" class="headerlink" title="Spring的请求分发机制"></a>Spring的请求分发机制</h2><p><a href="https://blog.csdn.net/javageektech/article/details/101805235">浅谈从纯Servlet到Spring的请求分发机制</a></p><p><strong>简单来说就是，在开发的过程中，我们不再把请求路径配置在 web.xml 里面，而是通过注解的方式配置在每一个个处理方法的上方。当 spring 框架启动后，会根据注解把每个处理方法初始化为一个个 MappingHandler（里面包括请求路径和处理逻辑），供 DispatcherServlet 调配使用。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Spring-框架核心组件简介&quot;&gt;&lt;a href=&quot;#Spring-框架核心组件简介&quot; class=&quot;headerlink&quot; title=&quot;Spring 框架核心组件简介&quot;&gt;&lt;/a&gt;Spring 框架核心组件简介&lt;/h2&gt;&lt;p&gt;&lt;font color = #E579B6&gt; 注解：&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我们在使用 Spring 时接触最多的就是各种注解，包括：&lt;br&gt;@Component&lt;br&gt;（把普通pojo实例化到spring容器中，相当于配置文件中的&lt;font color = red&gt; &amp;lt; bean id = “” class = “” /&amp;gt; &lt;/font&gt;）&lt;br&gt;@Controller、@Service、@Repository 等，这些都是 Spring 的核心组件。&lt;/p&gt;</summary>
    
    
    
    <category term="学习记录" scheme="http://cmblogs.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Spring" scheme="http://cmblogs.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>关于脏读、不可重复读、幻读以及Mysql的隔离级别</title>
    <link href="http://cmblogs.cn/2021/06/09/Mysql%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html"/>
    <id>http://cmblogs.cn/2021/06/09/Mysql%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html</id>
    <published>2021-06-09T08:50:05.000Z</published>
    <updated>2021-12-13T17:03:43.355Z</updated>
    
    <content type="html"><![CDATA[<hr><p>==关于上面这些问题，今天回顾的时候看了很多文章，发现之前有很多问题自己都是一知半解，所以重新写一篇文章，整理一下：==</p><span id="more"></span><h2 id="Mysql的隔离级别："><a href="#Mysql的隔离级别：" class="headerlink" title="Mysql的隔离级别："></a>Mysql的隔离级别：</h2><ul><li><p><strong>读未提交（Read Uncommitted）</strong><br>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别是最低的隔离级别，虽然拥有超高的并发处理能力及很低的系统开销，但很少用于实际应用。因为采用这种隔离级别只能防止第一类更新丢失问题，<strong>不能解决脏读，不可重复读及幻读问题</strong>。</p></li><li><p><strong>读已提交（Read Committed）</strong><br>这是大多数数据库系统的默认隔离级别（<strong>但不是MySQL默认的</strong>）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别可以防止脏读问题，<strong>但会出现不可重复读及幻读问题</strong>。</p></li><li><p><strong>可重复读（Repeatable Read）</strong><br>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这种隔离级别<strong>可以防止除幻读外的其他问题</strong>。</p></li><li><pre><code>**可串行化（Serializable）**</code></pre><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读、第二类更新丢失问题。在这个级别，可以解决上面提到的所有并发问题，但可能导致大量的超时现象和锁竞争，通常数据库不会用这个隔离级别，我们需要其他的机制来解决这些问题：乐观锁和悲观锁。</p></li></ul><p>四种隔离级别会产生的问题：<br>| 隔离级别                     | 脏读                  | 不可重复读            | 幻读                  | 第二类丢失更新        |<br>| —————————- | ——————— | ——————— | ——————— | ——————— |<br>| 读未提交（Read Uncommitted） | <font color = red> 会 | <font color = red> 会 | <font color = red> 会 | <font color = red> 会 |<br>| 读已提交（Read Committed）   | 不会                  | <font color = red> 会 | <font color = red> 会 | <font color = red> 会 |<br>| 可重复读（Repeatable Read）  | 不会                  | 不会                  | <font color = red> 会 | 不会                  |<br>| 可串行化（Serializable）     | 不会                  | 不会                  | 不会                  | 不会                  |</p><hr><h2 id="脏读（Dirty-Read）"><a href="#脏读（Dirty-Read）" class="headerlink" title="脏读（Dirty Read）"></a>脏读（Dirty Read）</h2><p>在不同的事务下，当前事务可以读到另外事务未提交的数据：</p><p>A事务执行过程中，B事务读取了A事务的修改。但是由于某些原因，A事务可能没有完成提交，发生了RollBack操作，则B事务所读取的数据就会是不正确的。这个未提交数据就是脏读（Dirty Read）。脏读产生的流程如下：<br><img src="https://img-blog.csdnimg.cn/20210417160127176.png" alt="在这里插入图片描述"></p><hr><h2 id="不可重复读（Nonrepeatable-Read）"><a href="#不可重复读（Nonrepeatable-Read）" class="headerlink" title="不可重复读（Nonrepeatable Read）"></a>不可重复读（Nonrepeatable Read）</h2><p>B事务读取了两次数据，在这两次的读取过程中A事务修改了数据，B事务的这两次读取出来的数据不一样。B事务这种读取的结果，即为不可重复读（Nonrepeatable Read）。不可重复读的产生的流程如下：<br><img src="https://img-blog.csdnimg.cn/20210417160254203.png" alt="在这里插入图片描述"></p><p><strong>这里拓展一下第二类丢失更新：</strong></p><p> 对于第二类丢失更新，也称为覆盖丢失，就是A和B一起执行一个数据，两个同时取到一个数据，然后B事物首先提交，但是A事物加下来又提交，这样就覆盖了B事物，称为第二类事物丢失，覆盖丢失。<br><img src="https://img-blog.csdnimg.cn/20210417163000415.png" alt="在这里插入图片描述"></p><hr><h2 id="幻读（Phantom-Read）"><a href="#幻读（Phantom-Read）" class="headerlink" title="幻读（Phantom Read）"></a>幻读（Phantom Read）</h2><p>B事务读取了两次数据，在这两次的读取过程中A事务添加了数据，B事务的这两次读取出来的集合不一样。幻读产生的流程如下：<br><img src="https://img-blog.csdnimg.cn/20210417163104124.png" alt="在这里插入图片描述"><br>这个流程看起来和不可重复读差不多，但幻读强调的是集合的增减，而不是单独一条数据的修改。</p><hr><p><strong>在这里还要再了解一下快照读和当前读：</strong></p><h2 id="快照读："><a href="#快照读：" class="headerlink" title="快照读："></a>快照读：</h2><p>普通读（也称快照读，英文名：Consistent Read），就是单纯的 SELECT 语句，不包括下面这两类语句：<br>==SELECT … FOR UPDATE<br>SELECT … LOCK IN SHARE MODE==</p><p> <strong>在RR(可重复读)级别下, 普通读是通过MVVC（多版本并发控制）和undo log来实现的</strong>，普通读的执行方式是生成 ReadView，直接利用 MVCC （多版本并发控制）机制来进行读取，并不会对记录进行加锁。</p><blockquote><p>对于 SERIALIZABLE 隔离级别来说，如果 autocommit 系统变量被设置为OFF，那普通读的语句会转变为锁定读，和在普通的 SELECT 语句后边加 LOCK IN SHARE MODE 达成的效果一样。</p></blockquote><h2 id="当前读："><a href="#当前读：" class="headerlink" title="当前读："></a>当前读：</h2><p>当前读（也称锁定读，Locking Read），当前读，读取的是最新版本，并且需要先获取对应记录的锁，如以下这些 SQL 类型：<br>==select … lock in share mode 、<br>select … for update、<br>update 、delete 、insert==</p><hr><h2 id="InnoDB在RR级别下有没有幻读"><a href="#InnoDB在RR级别下有没有幻读" class="headerlink" title="InnoDB在RR级别下有没有幻读"></a>InnoDB在RR级别下有没有幻读</h2><p>最后还要记录一下的就是这个今天研究了许久的问题：InnoDB引擎在REPEATABLE READ级别下有没有幻读</p><p>看了很多文章，最后的结论为 </p><p><strong>在RR级别下InnoDB默认只能解决快照读的幻读问题，当前读的幻读还是通过加Next-Key Lock来解决的</strong></p><p>InnoDB默认的隔离级别是RR（可重复读），<font color = red><strong>可以解决脏读和不可重复读，<font color = #3399EA>只解决了快照读情况下的幻读问题，<font color = #E579B6>当前读情况下解决幻读问题得靠next-key锁。</strong></p><p><strong>这里补充下行锁的 3 种算法：</strong></p><ul><li><p>行锁（Record Lock）：锁直接加在索引记录上面。</p></li><li><p>间隙锁（Gap Lock）：是 Innodb 为了解决幻读问题时引入的锁机制，所以只有在 Read Repeatable 、Serializable 隔离级别才有。</p></li><li><p>Next-Key Lock ：Record Lock + Gap Lock，锁定一个范围并且锁定记录本身 。</p></li></ul><p><strong>补充知识：</strong></p><ul><li>什么是MVCC？<br>多版本并发控制。InnoDB为每行记录添加了一个版本号（系统版本号），每当修改数据时，版本号加一。<br>在读取事务开始时，系统会给事务一个当前版本号，事务会读取版本号&lt;=当前版本号的数据，这时就算另一个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。</li></ul><ul><li><a href="https://blog.csdn.net/ahjxhy2010/article/details/81943181">MySQL的innodb引擎是如何实现MVCC的</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;==关于上面这些问题，今天回顾的时候看了很多文章，发现之前有很多问题自己都是一知半解，所以重新写一篇文章，整理一下：==&lt;/p&gt;</summary>
    
    
    
    <category term="学习记录" scheme="http://cmblogs.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Mysql" scheme="http://cmblogs.cn/tags/Mysql/"/>
    
    <category term="Innodb" scheme="http://cmblogs.cn/tags/Innodb/"/>
    
  </entry>
  
  <entry>
    <title>JVM系统整理</title>
    <link href="http://cmblogs.cn/2021/05/21/JVM%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86.html"/>
    <id>http://cmblogs.cn/2021/05/21/JVM%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86.html</id>
    <published>2021-05-21T04:50:10.000Z</published>
    <updated>2021-12-13T17:03:35.983Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210320103006245.png" alt="在这里插入图片描述"></p><h2 id="1、JVM的位置"><a href="#1、JVM的位置" class="headerlink" title="1、JVM的位置"></a>1、JVM的位置</h2><p><img src="https://img-blog.csdnimg.cn/20210320114419691.png" alt="在这里插入图片描述"></p><span id="more"></span><h2 id="2、JVM体系结构"><a href="#2、JVM体系结构" class="headerlink" title="2、JVM体系结构"></a>2、JVM体系结构</h2><p><img src="https://img-blog.csdnimg.cn/20210320114522187.png" alt="在这里插入图片描述"></p><blockquote><p>本地方法接口：JNI（Java Native Interface）</p></blockquote><h2 id="3、类加载器"><a href="#3、类加载器" class="headerlink" title="3、类加载器"></a>3、类加载器</h2><p>   <img src="https://img-blog.csdnimg.cn/2021032011460664.png" alt="在这里插入图片描述"></p><blockquote><p><strong>类是模板，对象是具体的</strong></p></blockquote><ul><li>1、虚拟机自带的加载器</li><li>2、启动类（根）加载器 — <strong>bootstrap</strong></li><li>3、扩展类加载器 — <strong>ext</strong></li><li>4、应用程序加载器 — <strong>app</strong> </li></ul><p><font color=red>注：从4 –&gt; 1 进行加载</font></p><br/><h2 id="4-1、双亲委派模型"><a href="#4-1、双亲委派模型" class="headerlink" title="4-1、双亲委派模型"></a>4-1、双亲委派模型</h2><p><strong>解释：双亲委派机制（安全）：APP –&gt; EXT –&gt; BOOT【最终执行】</strong></p><ol><li>类加载器收到类加载的请求</li><li>将这个请求向上委托为父类加载器去完成，一直向上委托，直到启动类加载器</li><li>启动类加载器检查是否能够加载当前的这个类，能加载就结束，使用当前的加载器，否则抛出异常，通知子加载器进行加载</li><li>重复步骤 3</li></ol><blockquote><p>但是BOOT根加载器输出是null，这是java调用不到~ C，C++        <br/><br>Java = C++ - - ：去掉繁琐的东西（指针、内存管理等）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.draco.parents;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双亲委派机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;? extends Car&gt; aClass1 = car1.getClass();</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = aClass1.getClassLoader();</span><br><span class="line"></span><br><span class="line">        System.out.println(classLoader);  <span class="comment">//AppClassLoader</span></span><br><span class="line"></span><br><span class="line">        System.out.println(classLoader.getParent());  <span class="comment">//ExtClassLoader  所在位置：\jre\lib\ext</span></span><br><span class="line"></span><br><span class="line">        System.out.println(classLoader.getParent().getParent());  <span class="comment">//null 1.不存在  2.java程序获取不到  所在位置：rt.jar</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br><img src="https://img-blog.csdnimg.cn/20210320120054573.png" alt="在这里插入图片描述"></p><br/><h2 id="4-2、面试问题"><a href="#4-2、面试问题" class="headerlink" title="4-2、面试问题"></a>4-2、面试问题</h2><ul><li><p><font color=red>为什么需要双亲委派机制？（优点）</font></p><p> 1、双亲委派机制使得类加载出现层级，父类加载器加载过的类，子类加载器不会重复加载，可以<strong>防止类重复加载</strong>；</p><p> 2、使得类的加载出现优先级，防止了核心API被篡改，提升了安全，所以越基础的类就会越上层进行加载，反而一般自己的写的类，就会在应用程序加载器（Application）直接加载。</p></li><li><p><font color=red>如何打破双亲委派？</font></p><p> 1、自定义类加载器，重写loadClass方法</p><p> 2、使用线程上下文类加载器</p></li></ul><h2 id="5、沙箱安全机制"><a href="#5、沙箱安全机制" class="headerlink" title="5、沙箱安全机制"></a>5、沙箱安全机制</h2><p> <strong>1. 什么是沙箱:</strong></p><p>沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。<strong>沙箱主要限制系统资源访问</strong>，那系统资源包括什么？——==CPU、内存、文件系统、网络==。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p> 所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p><p> <strong>2. 组成沙箱的基本组件:</strong></p><ul><li><strong>字节码校验器</strong>（bytecode verifier）:确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。</li><li><strong>类装载器</strong>（class loader）：其中类装载器在3个方面对Java沙箱起作用<br>它防止恶意代码去干涉善意的代码；<br>它守护了被信任的类库边界；<br>它将代码归入保护域，确定了代码可以进行哪些操作。</li></ul><p>虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。</p><p>类装载器采用的机制是==双亲委派模式==。</p><ol><li>从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；</li><li>由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。</li></ol><ul><li><strong>存取控制器</strong>（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。</li><li><strong>安全控制器</strong>（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。</li><li><strong>安全软件包</strong>（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：<br>安全提供者<br>消息摘要<br>数字签名<br>加密<br>鉴别</li></ul><h2 id="5、Native"><a href="#5、Native" class="headerlink" title="5、Native"></a>5、Native</h2><blockquote><p>Java在内存区域中专门开辟了一块标记区域——本地方法栈，用来登记native方法，凡是带了native关键字的，会进入到本地方法栈中，调用本地方法接口（JNI），在最终执行的时候，加载本地方法库中的方法通过JNI</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210327103150264.png" alt="在这里插入图片描述"></p><ul><li>JNI的作用：扩展Java的使用，融合不同的编程语言为Java所用，不过最初是想融合C，C++的，因为Java诞生的时候，C，C++横行，想要立足的话就要有能调用C的程序</li><li>本地方法栈：具体做法是，在Native Method Stack中登记native方法，在执行引擎执行的时候加载Native Libraies【本地库】</li></ul><h2 id="6、PC寄存器"><a href="#6、PC寄存器" class="headerlink" title="6、PC寄存器"></a>6、PC寄存器</h2><p>程序计数器：Program Counter Register</p><p> 每个线程都有一个程序计数器， 是线程私有的，就是一个指针， 指向方法区中的方法字节码(用来存储指向像一条指令的地址， 也即将要执行的指令代码)，在执行引擎读取下一条指令, 是一个非常小的内存空间，几乎可以忽略不计</p><h2 id="7、方法区"><a href="#7、方法区" class="headerlink" title="7、方法区"></a>7、方法区</h2><p>方法区：Method Area</p><p> 方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间；</p><p> 静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关。简单的来说就是：==static、final、Class、常量池==</p><h2 id="8、栈"><a href="#8、栈" class="headerlink" title="8、栈"></a>8、栈</h2><blockquote><p>栈：先进后出，后进先出<br>队列：先进先出（<strong>FIFO</strong>：first input first output）</p></blockquote><p>栈：栈内存，主管程序的运行，生命周期和线程同步；</p><p>线程结束，栈内存也就释放了，对于栈来说==不存在垃圾回收问题==，一旦线程结束，栈就Over了</p><p><strong>1. 栈里面存什么</strong> </p><p>栈：8大基本类型 + 对象的引用 + 实例的方法    </p><p><strong>2.栈运行原理</strong></p><p><img src="https://img-blog.csdnimg.cn/20210327103649597.png" alt="在这里插入图片描述"></p><p><strong>3. 栈堆方法区的交互关系</strong><br><img src="https://img-blog.csdnimg.cn/20210327103729154.png" alt="在这里插入图片描述"></p><h2 id="9、三种JVM"><a href="#9、三种JVM" class="headerlink" title="9、三种JVM"></a>9、三种JVM</h2><ul><li>Sun公司 ==HotSpot Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)==</li><li>BEA ==JRockit==</li><li>IBM ==J9VM==</li></ul><h2 id="10、堆"><a href="#10、堆" class="headerlink" title="10、堆"></a>10、堆</h2><blockquote><p>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。</p></blockquote><p> <strong>1. 堆里面存什么</strong></p><p> 类加载器读取了类文件后，一般会把什么东西放在堆中？ 类，方法，常量，变量，保存我们所有引用类型的真实对象</p><p>堆内存中还要细分为三个区域：</p><ul><li>新生区  Eden  survivor to / survivor from </li><li>老年区    old</li><li>永久代 prem / 元空间 metaspace</li></ul><p>==GC垃圾回收，主要在伊甸园区和老年区==<br><img src="https://img-blog.csdnimg.cn/20210327104248802.png" alt="在这里插入图片描述"></p><p>假设内存满了，OOM，堆内存不够  <strong>java.lang.OutOfMemoryError: Java heap space</strong></p><p><strong>2、新生区</strong></p><ul><li>新生区：类诞生和成长的地方，甚至死亡；<ul><li>伊甸园区，所有对象都是在伊甸园区new出来的</li><li>suvivor to / from<br><img src="https://img-blog.csdnimg.cn/20210327104814114.png" alt="在这里插入图片描述"></li></ul></li></ul><p><strong>3、老年区</strong></p><p>新生区没干掉，没杀死的来到了养老区~</p><p><strong>4、永久代 / 元空间</strong></p><p>这个区域是常驻内存的。用来存放JDK自身携带的Class对象，Interface元数据，存储的是Java运行时的一些环境或类信息，这个区域不存在垃圾回收！当关闭VM虚拟机就会释放这个区域的内存。</p><p>一个启动类加载了大量的第三方jar包；Tomcat部署了太多的应用；大量动态生成的反射类等 不断的被加载，直到内存满，就会出现OOM。</p><p>jdk1.6 之前：永久代，常量池是在方法区中；<br>jdk1.7 ：永久代，但是慢慢退化了，去永久代，常量池在堆中<br>jdk1.8 之后：无永久代，常量池在元空间</p><p><img src="https://img-blog.csdnimg.cn/20210327104928939.png" alt="在这里插入图片描述"></p><blockquote><p>元空间：逻辑上存在，物理上不存在</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.draco.heapOverflow;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元空间逻辑上存在，物理上不存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SanQu</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回jvm试图使用的最大内存</span></span><br><span class="line">        <span class="keyword">long</span> max = Runtime.<span class="built_in">getRuntime</span>().<span class="built_in">maxMemory</span>();</span><br><span class="line">        <span class="comment">// 返回jvm的初始化内存</span></span><br><span class="line">        <span class="keyword">long</span> total = Runtime.<span class="built_in">getRuntime</span>().<span class="built_in">totalMemory</span>();</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;max=&quot;</span>+max+<span class="string">&quot;字节\t&quot;</span>+(max/(<span class="number">1024</span>*<span class="number">1024</span>))+<span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;total=&quot;</span>+total+<span class="string">&quot;字节\t&quot;</span>+(total/(<span class="number">1024</span>*<span class="number">1024</span>))+<span class="string">&quot;MB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认情况下，试图分配的最大内存是电脑内存的1/4，而初始化的内存是1/64</span></span><br><span class="line">        <span class="comment">// -Xms1024m -Xmx1024m -XX:+PrintGCDetails</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/2021032710515496.png" alt="在这里插入图片描述"></p><p>当修改了VM选项后：-Xms1024m -Xmx1024m -XX:+PrintGCDetails，输出结果：</p><p><img src="https://img-blog.csdnimg.cn/20210327105200744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzY0NTY2Mw==,size_16,color_FFFFFF,t_70" alt="image-20210201230953431"></p><p>让我们来算一笔账，</p><p>新生区：305664k；养老区：699392k</p><p>加在一起：1,005,056k，除以1024后 = 981.5MB，等于jvm试图分配的最大内存，所以说元空间逻辑上存在，物理上不存在。</p><p><strong>5、出现OOM</strong></p><ol><li><p>尝试扩大堆内存去查看内存结果</p><p>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</p></li><li><p>若不行，分析内存，看一下是哪个地方出现了问题（专业工具）</p><ul><li>能够看到代码第几行出错：内存快照分析工具，MAT（eclipse），Jprofiler</li><li>Dubug，一行行分析代码！（不现实）</li></ul></li></ol><p>MAT，Jprofiler作用：</p><ul><li>分析Dump内存文件，快速定位内存泄漏</li><li>获得堆中的数据</li><li>获得大的对象</li><li>…</li></ul><p>运行出现堆溢出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.draco.heapOverflow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JprofilerTest</span> &#123;</span></span><br><span class="line">    byte[] array = <span class="keyword">new</span> byte[<span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;JprofilerTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                list.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">JprofilerTest</span>());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="built_in"><span class="keyword">catch</span></span> (Exception e)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;count=&quot;</span>+count);</span><br><span class="line">            e.<span class="built_in">printStackTrace</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置VM options -Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError后，再次运行，控制台输出：<br><img src="https://img-blog.csdnimg.cn/20210327105534230.png" alt="在这里插入图片描述"><br>找到HPROF快照<br><img src="https://img-blog.csdnimg.cn/2021032710554861.png" alt="在这里插入图片描述"><br>双击打开<br><img src="https://img-blog.csdnimg.cn/20210327105600507.png" alt="在这里插入图片描述"><br>修改代码，把try catch中的Exception改成Error后运行：<br><img src="https://img-blog.csdnimg.cn/20210327105613687.png" alt="在这里插入图片描述"></p><p><strong>6、VM options参数</strong></p><p>-Xms 设置初始化内存分配大小，默认1/64</p><p>-Xmx 设置最大分配内存，默认1/4</p><p>-XX:+PrintGCDetails 打印GC垃圾回收信息</p><p>-XX:+HeapDumpOnOutOfMemoryError 生成oomDump文件</p><p>-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</p><p>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</p><p><br/><br/></p><h2 id="11、GC垃圾回收"><a href="#11、GC垃圾回收" class="headerlink" title="11、GC垃圾回收"></a>11、GC垃圾回收</h2><p><strong>1、GC作用域</strong><br><img src="https://img-blog.csdnimg.cn/20210327105747110.png" alt="在这里插入图片描述"><br>JVM在进行GC时，并不是对这三个区域统一回收，大部分时候，回收都是新生代</p><ul><li>新生代</li><li>幸存区（form to）【会交换的，不是一成不变的】</li><li>老年区</li></ul><p>GC两种类型：轻GC（普通的GC），重GC（全局GC）</p><p><strong>2、GC相关题目</strong></p><ul><li>JVM的内存模型和分区~详细到每个区放什么？</li><li>堆里面的分区有哪些？Eden，from，to，old，说说他们的特点~</li><li>GC的算法有哪些？标记清除法，标记整理/压缩法，复制算法，引用计数法，怎么用的？</li><li>轻GC和重GC分别在什么时候发生？</li></ul><p><strong>3、GC算法</strong></p><ul><li><strong>引用计数法</strong><br><img src="https://img-blog.csdnimg.cn/20210327110104190.png" alt="在这里插入图片描述"></li></ul><hr><ul><li><strong>复制算法</strong><br><img src="https://img-blog.csdnimg.cn/20210327110159219.png" alt="在这里插入图片描述"></li></ul><blockquote><p>一般新生代（伊甸园区、幸存区）会使用复制算法，生成新的to区</p></blockquote><p><strong>好处：</strong></p><ul><li>没有内存碎片</li></ul><p><strong>坏处：</strong></p><ul><li>浪费了内存空间</li></ul><p>==复制算法最佳使用场景：对象存活度较低的时候，也就是新生区==</p><hr><ul><li><strong>标记清除</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/202103271104076.png" alt="在这里插入图片描述"></p><p><strong>优点：</strong></p><ul><li>不用浪费额外的空间</li></ul><p><strong>缺点：</strong></p><ul><li>不连续的空间会产生内存碎片</li><li>两次扫描，浪费时间</li></ul><hr><ul><li><strong>标记压缩</strong></li></ul><p>对于标记清除的再压缩</p><p><img src="https://img-blog.csdnimg.cn/20210327110541985.png" alt="在这里插入图片描述"><br>但是又多了一个移动成本</p><hr><p><strong>总结</strong></p><p>内存效率：复制算法 &gt; 标记清除算法 &gt; 标记压缩算法（时间复杂度）</p><p>内存整齐度：复制算法 = 标记压缩算法 &gt; 标记清除算法</p><p>内存利用率：标记压缩算法 = 标记清除算法 &gt; 复制算法</p><p>思考：难道没有最优算法吗？</p><p>答案：没有，没有最好的算法，只有最合适的——&gt;GC：分代收集算法</p><p><strong>年轻代：</strong></p><ul><li>存活率低 –&gt; 复制算法</li></ul><p><strong>老年代：</strong></p><ul><li>区域大，存活率高 –&gt;  标记清除 + 标记压缩混合实现</li></ul><hr><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><ol><li><p>什么是JMM？</p><p>JMM：Java Memory Model的缩写</p></li><li><p>作用：</p><p>作用：缓存一致性协议，用于定义数据读写的规则。</p><p>JMM定义了线程工作内存和主内存之间的抽象关系，线程之间的共享内存存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory） </p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210327110922404.png" alt="在这里插入图片描述"></p><p>解决共享对象可见性这个问题：voliate</p><ol start="3"><li><p>它该如何学习？</p><p>JMM：抽象的概念，理论</p><p>voliate等等</p></li></ol><p>最后：==拥抱开源时代，享受技术给我们带来的新体验==</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210320103006245.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、JVM的位置&quot;&gt;&lt;a href=&quot;#1、JVM的位置&quot; class=&quot;headerlink&quot; title=&quot;1、JVM的位置&quot;&gt;&lt;/a&gt;1、JVM的位置&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210320114419691.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习记录" scheme="http://cmblogs.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JVM" scheme="http://cmblogs.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java学习记录</title>
    <link href="http://cmblogs.cn/2021/04/08/Java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html"/>
    <id>http://cmblogs.cn/2021/04/08/Java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html</id>
    <published>2021-04-08T08:50:05.000Z</published>
    <updated>2021-12-13T17:03:24.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、动态代理与反射"><a href="#1、动态代理与反射" class="headerlink" title="1、动态代理与反射"></a>1、动态代理与反射</h2><p><a href="https://www.cnblogs.com/jacksontao/p/8552357.html">https://www.cnblogs.com/jacksontao/p/8552357.html</a><br>对于反射：讲的通俗一点的话就是，对于jvm来说，.java文件必须要先编译为.class文件才能够被jvm执行，所以在编译为.class文件的过程中，对象的类型都会被指定好，比如说 User user。那么如果说我想在代码运行的过程中获取到对象的类型呢？或者说程序在运行过程中如何载入一个特定的类呢？这就涉及到了java的反射机制了，反射提供了一套能够让我们在代码运行时也能获取到类型属性的方法。<br>而动态代理，利用java反射机制，动态的生成了一个代理类，直接调用代理方法即可。</p><p><br /><br /></p><span id="more"></span><h2 id="2、int和Integer的区别"><a href="#2、int和Integer的区别" class="headerlink" title="2、int和Integer的区别"></a>2、int和Integer的区别</h2><p><a href="https://www.cnblogs.com/guodongdidi/p/6953217.html">https://www.cnblogs.com/guodongdidi/p/6953217.html</a><br>自动装箱与自动拆箱<br><br /></p><p>String a = “a”;    String b = “a”;    这样定义的a和b指向的是字符串常量区变量，地址是一样的，即用equals为true，用” = = “也为true。<br>    但是     String a =new String( “a”);       String b = new String( “a”);      这样是定义了两个堆内存对象，只能equals，不能 “ == “</p><p>（1）int与Integer、new Integer()进行= =比较时，结果永远为true<br>（2）Integer与new Integer()进行= =比较时，结果永远为false<br>（3）Integer与Integer进行==比较时，看范围；在大于等于-128小于等于127的范围内为true，在此范围外为false。<br><br /></p><p><strong>Java中的四类八种基本数据类型</strong><br>  第一类：整数类型  byte short int long<br> 第二类：浮点型  float double<br> 第三类：逻辑型  boolean(它只有两个值可取true false)<br>  第四类：字符型  char</p><p><br /><br /><br /></p><h2 id="3、面向对象的四大特性"><a href="#3、面向对象的四大特性" class="headerlink" title="3、面向对象的四大特性"></a>3、面向对象的四大特性</h2><p><a href="https://www.cnblogs.com/msn-z/p/7802576.html">https://www.cnblogs.com/msn-z/p/7802576.html</a></p><p><br /><br /><br /></p><h2 id="4、数组、链表、红黑树"><a href="#4、数组、链表、红黑树" class="headerlink" title="4、数组、链表、红黑树"></a>4、数组、链表、红黑树</h2><p><strong>数组：</strong><br><strong>查询快：</strong> 数组的地址是连续的，通过首地址和索引可以快速查找某个元素<br><strong>增删慢：</strong> 数组的长度是固定的，增删的时候其实是创建了一个新的数组，把仍然保存的元素复制到新数组中，原数组会在内存中被销毁（垃圾回收）</p><p><strong>链表：</strong><br><strong>查询慢：</strong> 链表中的地址不是连续的，每次查询元素都必须从头开始查询<br><strong>增删快：</strong> 链表的结构，增删某一元素对整体结构没有影响，所以增删快<br><img src="https://img-blog.csdnimg.cn/20200907212158907.png#pic_center" alt="在这里插入图片描述"><br>链表还分为单向和双向，双向链表是有序的<br><img src="https://img-blog.csdnimg.cn/20200907212436721.png#pic_center" alt="在这里插入图片描述"></p><p><strong>红黑树：</strong><br><img src="https://img-blog.csdnimg.cn/20200907213841600.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200907213914400.png#pic_center" alt="在这里插入图片描述"><br><br /><br /><br /></p><h2 id="5、List、Set、Collection、Map的区别和联系"><a href="#5、List、Set、Collection、Map的区别和联系" class="headerlink" title="5、List、Set、Collection、Map的区别和联系"></a>5、List、Set、Collection、Map的区别和联系</h2><p><img src="https://img-blog.csdnimg.cn/20210304175255199.png" alt="在这里插入图片描述"></p><p><a href="https://blog.csdn.net/qq_44863974/article/details/95803762">https://blog.csdn.net/qq_44863974/article/details/95803762</a></p><p><a href="https://blog.csdn.net/qq_36520235/article/details/82417949">https://blog.csdn.net/qq_36520235/article/details/82417949</a></p><p><strong>Collection</strong>：Java.util下的一个接口，是各种集合结构的父接口，List和Set是继承自它的子接口，Collection是最基本的集合接口，Java SDK中不提供直接继承自Collection的类，而是提供继承自它子接口的类，如List和Set。所有的Collection类都支持一个Iterator()方法来遍历。</p><p><strong>List</strong>：List接口是有序的，会精确的将元素插入到指定的位置（允许有相同元素）。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>ArrayList</strong>：List接口实现类，实现可变大小的数组，允许所有的元素，底层用数组实现，可以随机访问（访问效率高，插入和删除效率低），不是同步的，也就是没有同步方法，线程不安全。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>LinkedList</strong>：List接口实现类，允许null元素，通常在首部或者尾部操作，所以常被使用做堆栈（Stack）、队列（Queue）和双向队列（Deque），底层用链表实现，插入删除效率高，访问效率低，不是同步的，也就是没有同步方法，线程不安全。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Vector</strong>：List接口实现类，类似于ArrayList，底层用数组实现，但Vector是同步的，线程安全（Stack继承自Vector）。</p><br/><p><strong>Set</strong>:是一种不包含重复元素的Collection接口，只关心元素是否属于Set（不允许有相同元素）,而不关心它的顺序。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>HashSet</strong>：Set接口实现类，不能有重复元素，底层使用HashMap实现，是为快速查找设计的Set，存入HashSet的对象必须定义HashCode()。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>LinkedHashSet</strong>：继承自HashSet，具有HashSet的查询速度，底层使用链表实现（维护元素的插入次序），于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>TreeSet</strong>：Set接口实现类，保存次序的Set，底层使用树结构实现，使用它可以从Set中提取有序的序列。</p><br/><p><strong>Map</strong>：是键值对映射集合，且为一一映射，键不能重复，值可以，所以是用键来索引值（即此接口实现Key到Value的映射，一个Map中不能包含相同的Key，但可以包含相同的Value，每个Key只能映射一个Value）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>HashTable</strong>：Map接口实现类，实现了一个Key-Value的哈希表，不能存储null值，每一个非null元素都可以作为Key或者Value，是同步的，也是线程安全的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>HashMap</strong>：可以存储null值，不是同步的，也不是线程安全的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>ConcurrentHashMap</strong>:线程安全。<br><br /><br><img src="https://img-blog.csdnimg.cn/20200909151021910.png#pic_center" alt="在这里插入图片描述"><br>JDK1.9以后（还没用过）List、Set、Map新增了一个静态方法of，但用of返回集合后就不能再添加新的元素，并且Set、Map不能有重复元素：<br><img src="https://img-blog.csdnimg.cn/2020091215271458.png#pic_center" alt="在这里插入图片描述"><br><br /><br /><br /></p><h2 id="6、异常产生的过程解析"><a href="#6、异常产生的过程解析" class="headerlink" title="6、异常产生的过程解析"></a>6、异常产生的过程解析</h2><p><img src="https://img-blog.csdnimg.cn/20200913105703846.png#pic_center" alt="在这里插入图片描述"></p><p>大致分成以下步骤：<br>    1、JVM创建一个异常对象，里面包括<strong>异常产生的位置，异常内容，异常原因</strong><br>    2、在产生异常的方法中如果没有异常处理逻辑，就会把异常抛出到调用该方法的方法中，如果都没有异常处理逻辑，最后会抛出给JVM<br>    3、JVM会把异常对象用红色字体打印在控制台，并终止当前正在进行的JAVA程序（中断处理）</p><p><br /><br /><br /></p><h2 id="7、try-catch注意事项"><a href="#7、try-catch注意事项" class="headerlink" title="7、try catch注意事项"></a>7、try catch注意事项</h2><p>1、如果有多个catch并且捕获的异常有子父类的关系，子类必须写在上面，否则会报错<br>2、如果finally中有return语句，运行时永远返回finally中的结果，避免该情况<br>3、子父类异常：<br><img src="https://img-blog.csdnimg.cn/20200913143126887.png#pic_center" alt="在这里插入图片描述"></p><p><br /><br /><br /></p><h2 id="8、自定义异常："><a href="#8、自定义异常：" class="headerlink" title="8、自定义异常："></a>8、自定义异常：</h2><p><img src="https://img-blog.csdnimg.cn/20200913143537117.png#pic_center" alt="在这里插入图片描述"><br><br /><br /><br /></p><h2 id="9、多线程："><a href="#9、多线程：" class="headerlink" title="9、多线程："></a>9、多线程：</h2><p>1、通过Thread扩展类实现多线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里面需要重写run方法</span></span><br><span class="line"><span class="comment">并且在main方法中new一个对象，调用该对象的start()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、通过Runnable接口实现多线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里面需要重写run方法</span></span><br><span class="line"><span class="comment">并且在main方法中new一个对象Runnable接口对象run</span></span><br><span class="line"><span class="comment">再new一个Thread类对象 Thread t = new Thread(run);</span></span><br><span class="line"><span class="comment">再调用t.start()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、实现Runnable接口创建多线程的好处：<br><img src="https://img-blog.csdnimg.cn/20200914220723420.png#pic_center" alt="在这里插入图片描述"><br>4、通过匿名内部类实现线程创建：</p><p><img src="https://img-blog.csdnimg.cn/20200914221024882.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">匿名内部类的创建格式为： <span class="keyword">new</span> 父类构造器（参数列表）|实现接口（）&#123;...&#125;       </span><br><span class="line">使用匿名内部类时，必须继承一个类或实现一个接口       </span><br><span class="line">匿名内部类由于没有名字，因此不能定义构造函数       </span><br><span class="line">匿名内部类中不能含有静态成员变量和静态方法</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类中的main方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//1、用Thread</span></span><br><span class="line"><span class="comment">//线程的父类是Thread</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="comment">//重写run方法，设置线程任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;...&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、用Runnable接口</span></span><br><span class="line">Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"><span class="comment">//重写run方法，设置线程任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;...&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化上面的方法，直接把 new... 传进去</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"><span class="comment">//重写run方法，设置线程任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;...&#125;.start();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /><br /><br /></p><h2 id="10、线程安全："><a href="#10、线程安全：" class="headerlink" title="10、线程安全："></a>10、线程安全：</h2><p>当同时有多个线程在执行时，如果不采取措施，很可能就会出现线程安全问题，解决线程安全问题有以下几种方法：<br /><br>1、使用同步代码块<br>    格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">可能会出现线程安全问题的代码（访问了共享资源的代码）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020091810423447.png#pic_center" alt="在这里插入图片描述"><br><font color=red >同步技术保证了只能有一个线程在同步中执行共享数据，保证了安全<br>但程序频繁的判断、获取、释放锁降低了程序执行的效率</font><br><br /><br>2、使用同步方法<br>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值 方法名(参数列表)&#123;</span><br><span class="line">可能会出现线程安全问题的代码（访问了共享资源的代码）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><p>3、使用Lock锁<br><img src="https://img-blog.csdnimg.cn/20200918112220123.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lock l = ...; </span><br><span class="line">l.lock(); </span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// access the resource protected by this lock &#125; </span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span> &#123; l.unlock(); &#125; </span><br></pre></td></tr></table></figure><p><font color=red >当在不同范围内发生锁定和解锁时，必须注意确保在锁定时执行的所有代码由try-finally或try-catch保护，以确保在必要时释放锁。</font></p><br /><h2 id="11、等待与唤醒机制"><a href="#11、等待与唤醒机制" class="headerlink" title="11、等待与唤醒机制"></a>11、等待与唤醒机制</h2><br /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">导致当前线程等待，直到另一个线程调用该对象的 <span class="title">notify</span><span class="params">()</span>方法或 <span class="title">notifyAll</span><span class="params">()</span>方法。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span></span><br><span class="line"><span class="function">导致当前线程等待，直到另一个线程调用 <span class="title">notify</span><span class="params">()</span>方法或该对象的 <span class="title">notifyAll</span><span class="params">()</span>方法，或者指定的时间已过。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">唤醒正在等待对象监视器的单个线程。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">唤醒正在等待对象监视器的所有线程。 </span></span><br></pre></td></tr></table></figure><p>多用于线程间的通信，使得多个线程可以符合我们的预期 有序的执行。 </p><br /><h2 id="12、线程池"><a href="#12、线程池" class="headerlink" title="12、线程池"></a>12、线程池</h2><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">线程池描述</a></p><p>线程池：容器–&gt;集合（ArrayList，Hashset，**LinkedList<Thread>**，HashMap）<br><img src="https://img-blog.csdnimg.cn/20200927154626349.png#pic_center" alt="在这里插入图片描述"><br><br /></p><h2 id="13、lambda表达式"><a href="#13、lambda表达式" class="headerlink" title="13、lambda表达式"></a>13、lambda表达式</h2><p><strong>面向对象思想：做一件事情，找一个可以做这个事情的对象，调用该对象的方法，完成事情<br>函数式编程思想：只要能获取到结果，谁去做的，怎么做的都不重要，重视结果 不看重过程</strong><br><br/><br><strong>lambda标准格式：</strong><br>lambda表达式省去了面向对象的条条框框，格式由3部分组成：<br>    <strong>一些参数、一个箭头、一段代码</strong><br>    <img src="https://img-blog.csdnimg.cn/20200927161204242.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200927164531938.png#pic_center" alt="在这里插入图片描述"><br><strong>使用lambda表达式的前提：</strong><br><img src="https://img-blog.csdnimg.cn/20200927170102430.png#pic_center" alt="在这里插入图片描述"></p><h2 id="14、File类"><a href="#14、File类" class="headerlink" title="14、File类"></a>14、File类</h2><p><strong>遍历目录：</strong><br><img src="https://img-blog.csdnimg.cn/20200928163830603.png#pic_center" alt="在这里插入图片描述"><br><br /></p><h2 id="15、递归"><a href="#15、递归" class="headerlink" title="15、递归"></a>15、递归</h2><p><strong>例1：</strong><br><img src="https://img-blog.csdnimg.cn/20201005200723428.png#pic_center" alt="在这里插入图片描述"><br>代码：<br><img src="https://img-blog.csdnimg.cn/20201005200758253.png#pic_center" alt="在这里插入图片描述"><br><br /></p><p><strong>例2：</strong><br><img src="https://img-blog.csdnimg.cn/20201005201126657.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201008205417911.png#pic_center" alt="在这里插入图片描述"></p><p>代码:<br><img src="https://img-blog.csdnimg.cn/20201008205542528.png#pic_center" alt="在这里插入图片描述"><br><br /><br /></p><h2 id="16、IO流"><a href="#16、IO流" class="headerlink" title="16、IO流"></a>16、IO流</h2><p><img src="https://img-blog.csdnimg.cn/20201009151859471.png#pic_center" alt="在这里插入图片描述"><br>一个中文：GBK编码占用两个字节，UTF-8编码占用三个字节<br><br /><br>字符输出流写入硬盘与字节输出流的一个区别是：<br>字节输出流直接使用write()方法把数据写入硬盘中<br>字符输出流使用write()方法是是把字符转换为字节，将字节写入内存缓冲区，需要再使用flush()方法    把内存缓冲区的数据刷新到文件中（colse方法使用时也会将内存缓冲区的数据刷新到文件中）<br><img src="https://img-blog.csdnimg.cn/2020100920265897.png#pic_center" alt="在这里插入图片描述"></p><br /><p>字节字符流的续写和换行：<br><img src="https://img-blog.csdnimg.cn/20201009203349753.png#pic_center" alt="在这里插入图片描述"><br><br /></p><p>在JDK7之前使用try catch处理流的异常：<br><img src="https://img-blog.csdnimg.cn/20201009204256545.png#pic_center" alt="在这里插入图片描述"></p><p>JDK7的新特性：<br><img src="https://img-blog.csdnimg.cn/20201009204638490.png#pic_center" alt="在这里插入图片描述"><br>JDK9的新特性：<br><img src="https://img-blog.csdnimg.cn/20201009204919980.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、动态代理与反射&quot;&gt;&lt;a href=&quot;#1、动态代理与反射&quot; class=&quot;headerlink&quot; title=&quot;1、动态代理与反射&quot;&gt;&lt;/a&gt;1、动态代理与反射&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jacksontao/p/8552357.html&quot;&gt;https://www.cnblogs.com/jacksontao/p/8552357.html&lt;/a&gt;&lt;br&gt;对于反射：讲的通俗一点的话就是，对于jvm来说，.java文件必须要先编译为.class文件才能够被jvm执行，所以在编译为.class文件的过程中，对象的类型都会被指定好，比如说 User user。那么如果说我想在代码运行的过程中获取到对象的类型呢？或者说程序在运行过程中如何载入一个特定的类呢？这就涉及到了java的反射机制了，反射提供了一套能够让我们在代码运行时也能获取到类型属性的方法。&lt;br&gt;而动态代理，利用java反射机制，动态的生成了一个代理类，直接调用代理方法即可。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习记录" scheme="http://cmblogs.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Java" scheme="http://cmblogs.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>手撕算法</title>
    <link href="http://cmblogs.cn/2021/03/14/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95.html"/>
    <id>http://cmblogs.cn/2021/03/14/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95.html</id>
    <published>2021-03-14T03:50:05.000Z</published>
    <updated>2021-12-13T17:04:12.531Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/2021031213260843.png" alt="在这里插入图片描述"></p><span id="more"></span><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="1、最小路径和-✔"><a href="#1、最小路径和-✔" class="headerlink" title="1、最小路径和  ✔"></a>1、最小路径和 <font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></p><p><strong>思路:</strong></p><ol><li>n为行数，m为列数，设dp[][] 为n×m的矩阵， dp[i][j] 就是走到该位置的最小路径和</li><li><strong>确定边界：</strong> <pre><code>- 当 i = 0 ，j ≠ 0 时，只能从左边来，所以 grid[i][j] += grid[i][j-1]; - 当 i ≠ 0 ，j = 0 时，只能从上边来，所以 grid[i][j] += grid[i-1][j];- 除去上面两种情况，其他都可以从上边或左边过来，这时候就要选择路径和更小的那个：    grid[i][j] += Math.min( grid[i-1][j] , grid[i][j-1] );</code></pre></li><li>通过观察可以发现我们可以直接在原矩阵的基础上进行修改，而不需要占用额外的空间。</li></ol><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length,m = grid[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;   <span class="comment">//行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;   <span class="comment">//列</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//第一行,只能从左边来</span></span><br><span class="line">                    grid[i][j] += grid[i][j<span class="number">-1</span>]; </span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//第一列,只能从上边来</span></span><br><span class="line">                    grid[i][j] += grid[i<span class="number">-1</span>][j]; </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//非第一行第一列 需要判断哪边的值更小,就加哪边</span></span><br><span class="line">                    grid[i][j] += Math.<span class="built_in">min</span>(grid[i<span class="number">-1</span>][j],grid[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n*m)，需要遍历整个矩阵一次</li><li>空间复杂度：O(1)</li></ul><p><br/><br/></p><h2 id="2、最长递增子序列-✔"><a href="#2、最长递增子序列-✔" class="headerlink" title="2、最长递增子序列 ✔"></a>2、最长递增子序列 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a></p><blockquote><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-java-by-scarb-v0ha/">参考答案</a></p></blockquote><p>这道题考虑使用动态规划：</p><p>我们定义dp[i]为当前index = i时数组的最长严格递增子序列长度。关键的问题在于我们怎么去计算dp数组的每个值。</p><p><strong>状态转移公式</strong></p><p>假设我们已经知道了 dp[0..4] 的所有结果，我们如何通过这些已知结果推出 dp[5] 呢？<br><img src="https://img-blog.csdnimg.cn/20210320163352308.png" alt="在这里插入图片描述"><br>很明显，<strong>nums[5] = 3</strong>，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，再将这个新的子序列长度加一</p><p>显然，可能形成很多种新的子序列，但是我们只选择最长的那一个，把最长子序列的长度作为 dp[5] 的值即可。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3398f4a2569c7f5d95f305e921f1253a.gif#pic_center" alt="https://pic.leetcode-cn.com/8fe73d010abfdbb0ff4950e96640bb8a04391fc7438fed845ab6d36208468266.gif"></p><p><strong>所以这道题我们需要做的有：</strong></p><ul><li>在刚开始时定义 dp[i] = 1，因为最短的序列就是单独一个数字</li><li>遍历数组的时候，比较 i（后） 与 j （前），如果 nums[i] &gt; nums[j] 则 nums[i]  可以接上 nums[j]  成为一个更长的递增子序列。我们就可以让 <strong>dp[i] =  Math.max(dp[i],dp[j]+1)  &lt;–</strong>   如果这一步能想明白，那么整道题就迎刃而解</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);   <span class="comment">//将数组全部替换成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);   <span class="comment">//最重要的公式，求出最长的递增子序列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, dp[i]);   <span class="comment">//遍历取出最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n^2)，其中 n 为数组 nums 的长度。动态规划的状态数为 n，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n^2)</li><li>空间复杂度：O(n)，需要额外使用长度为 n 的 dp 数组。</li></ul><p><br/><br/></p><h2 id="3、三角形-✔"><a href="#3、三角形-✔" class="headerlink" title="3、三角形 ✔"></a>3、三角形<font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和</a></p><p><strong>思路：</strong></p><ol><li>使用动态规划，定义 dp[][] ，大小为n行m列，dp[i][j] 就是走到该位置的最小路径和</li><li><strong>确定边界： i为行数</strong> <pre><code>- 当 j = 0 时，只能从 j 来，所以 triangle.get(i).set ( j , triangle.get(i).get(j) + triangle.get(i-1).get(j));- 当 j = i 时，只能从 j-1 来，所以 triangle.get(i).set ( j , triangle.get(i).get(j) + triangle.get(i-1).get(j-1));- 除去上面两种情况，其他都可以从 j 或 j-1 过来，这时候就要选择路径和更小的那个：    int min = Math.min ( triangle.get(i-1).get(j) , triangle.get(i-1).get(j-1) );            triangle.get(i).set ( j , triangle.get(i).get(j) + min);</code></pre></li><li>当 i=n-1 时，即为最后一行，我们需要维护一个最小路径和ans</li></ol><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> triangle.<span class="built_in">get</span>(<span class="number">0</span>).<span class="built_in">get</span>(<span class="number">0</span>);   <span class="comment">// 如果只有一行</span></span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i &lt; n;i++)&#123;    <span class="comment">//从第二行开始遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= i;j++)&#123;</span><br><span class="line">                <span class="comment">// 列为0，即在左边，只能从j下来</span></span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>) triangle.<span class="built_in">get</span>(i).<span class="built_in">set</span>(j,triangle.<span class="built_in">get</span>(i).<span class="built_in">get</span>(j) + triangle.<span class="built_in">get</span>(i<span class="number">-1</span>).<span class="built_in">get</span>(j));</span><br><span class="line">                <span class="comment">// 列为i，即在右边，只能从j-1下来</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == i) triangle.<span class="built_in">get</span>(i).<span class="built_in">set</span>(j,triangle.<span class="built_in">get</span>(i).<span class="built_in">get</span>(j) + triangle.<span class="built_in">get</span>(i<span class="number">-1</span>).<span class="built_in">get</span>(j<span class="number">-1</span>));</span><br><span class="line">                <span class="comment">// 列在中间，可以从j或j-1下来 需要判断</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> min = Math.<span class="built_in">min</span>(triangle.<span class="built_in">get</span>(i<span class="number">-1</span>).<span class="built_in">get</span>(j),triangle.<span class="built_in">get</span>(i<span class="number">-1</span>).<span class="built_in">get</span>(j<span class="number">-1</span>));</span><br><span class="line">                    triangle.<span class="built_in">get</span>(i).<span class="built_in">set</span>(j,triangle.<span class="built_in">get</span>(i).<span class="built_in">get</span>(j) + min);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == n<span class="number">-1</span>) ans = Math.<span class="built_in">min</span>(ans,triangle.<span class="built_in">get</span>(i).<span class="built_in">get</span>(j));   <span class="comment">//最后一行，维护最小答案</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br><img src="https://img-blog.csdnimg.cn/20210322171126281.png" alt="在这里插入图片描述"></p><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n^2)，n为三角形行数，并且在更改原集合的情况下，我们频繁使用get和set方法，也会消耗一定的性能</li><li>空间复杂度：O(1)</li></ul><blockquote><p><strong><a href="https://leetcode-cn.com/problems/triangle/solution/di-gui-ji-yi-hua-dp-bi-xu-miao-dong-by-sweetiee/">看了题解</a>之后的答案：</strong></p></blockquote><p>定义二维 dp 数组，自底向上的递推</p><p><strong>状态定义：</strong></p><p>dp[i][j] 表示从点 (i, j)到底边的最小路径和</p><p><strong>状态转移方程（自底向上）：</strong></p><p>dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + triangle[i][j]</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示从点 (i, j) 到底边的最小路径和。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 从三角形的最后一行开始递推。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.<span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + triangle.<span class="built_in">get</span>(i).<span class="built_in">get</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N^2)，N 为三角形的行数</li><li>空间复杂度：O(N^2)，N 为三角形的行数</li></ul><br/><p><strong>空间优化：</strong><br>在上述代码中，我们定义了一个 N 行 N 列 的 dp 数组<br>但是在实际递推中我们发现，计算 dp[i][j] 时，只用到了下一行的 dp[i + 1][j] 和 dp[i + 1][j + 1]<br>因此 dp 数组不需要定义 N 行，只要定义 1 行就足够：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];   <span class="comment">//用于防止j+1越界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[j] = Math.<span class="built_in">min</span>(dp[j], dp[j + <span class="number">1</span>]) + triangle.<span class="built_in">get</span>(i).<span class="built_in">get</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N^2)，N 为三角形的行数</li><li>空间复杂度：O(N)，N 为三角形的行数</li></ul><p><br/><br/></p><h2 id="4、找零钱-✔"><a href="#4、找零钱-✔" class="headerlink" title="4、找零钱 ✔"></a>4、找零钱<font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></p><blockquote><p><a href="https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-dong-tai-gui-hua-e2nt7/">答案看的这个</a></p></blockquote><p><strong>思路:</strong></p><ol><li>dp[j] 代表的含义：就是amount在这个coins组合下最少用多少枚硬币</li></ol><blockquote><p>可以转化为完全背包问题 ： 填满容量为amount的背包最少需要多少硬币</p></blockquote><ol start="2"><li><p>初始化dp的问题：后面要求的是最少的硬币，所以初始化不能对结果造成影响，而因为硬币的数量一定不会超过amount（面值最低为1），所以直接初始化dp数组的值为amount+1，<strong>特例 dp[0] = 0;</strong></p></li><li><p>最重要的<strong>转移方程： dp[j] = Math.min(dp[j], dp[j-coin] + 1)</strong><br>当前填满容量j最少需要的硬币 = min( 之前填满容量j最少需要的硬币, 填满容量 j - coin 需要的硬币 + 1个当前硬币）</p></li><li><p>返回dp[amount]，如果dp[amount]的值为10001没有变过，说明找不到硬币组合，返回-1</p></li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = amount + <span class="number">1</span>;   </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[a];  <span class="comment">//定义amount+1</span></span><br><span class="line">        Arrays.fill(dp, a);  <span class="comment">//因为硬币的数量一定不会超过amount</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">//当amount == 0 时 返回0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = coin; j &lt; a; j++)&#123;   <span class="comment">//从每个硬币的面值开始遍历到amount</span></span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - coin] + <span class="number">1</span>);  </span><br><span class="line">                   <span class="comment">//这个转移方程就是dp[amount]在这个coins组合下最少用多少枚硬币</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == a ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><p><a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 II</a></p><blockquote><p><a href="https://leetcode-cn.com/problems/coin-change-2/solution/518-ling-qian-dui-huan-iidong-tai-gui-hu-5xy2/">–&gt; 答案参考</a></p></blockquote><p><strong>思路：</strong></p><ol><li> dp[j] 代表 j 金额 在当前的 coins 组合下有多少种组合方式</li></ol><blockquote><p>也可转化为完全背包之组合问题——dp[j] 代表装满容量为j的背包有几种硬币<strong>组合</strong></p></blockquote><ol start="2"><li>列出转移方程：dp[j] = dp[j] + dp[j - coin]<br>当前填满 j 容量的方法数 = 之前填满 j 容量的硬币组合数 + 填满 j - coin 容量的硬币组合数</li></ol><p><strong>也就是当前硬币coin的加入，可以把 j - coin 容量的组合数加入进来</strong><br> 3.  <strong>dp[0] = 1;</strong> 即金额为0时只有一种组合coins的方式（都不用）</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[j] 代表 amount金额 在当前的 coins 组合下有多少种组合方式</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin:coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = coin;j &lt; amount+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j-coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="5、最大字段和-✔"><a href="#5、最大字段和-✔" class="headerlink" title="5、最大字段和 ✔"></a>5、最大字段和<font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和</a></p><p>这道题要我们找到一个具有最大和的连续子数组，可以转换为求以 i 结尾的连续子数组的最大和，考虑使用动态规划，**列出转移方程：dp[i] = Math.max( dp[i-1]+nums[i] , nums[i] )**，遍历数组输出dp[ ]最大值即可</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//dp[i]表示下标j的连续子数组最大和</span></span><br><span class="line">       <span class="keyword">int</span> n = nums.length,ans = nums[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>) dp[i] = Math.<span class="built_in">max</span>(nums[i],dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">            ans = Math.<span class="built_in">max</span>(dp[i],ans);</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是通过观察我们可以发现，dp数组每次都只会使用dp[i]，我们可以考虑用一个数字pre代替dp数组，改进后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//简化 --&gt; pre为前一个数的连续子数组最大和  </span></span><br><span class="line">       <span class="keyword">int</span> pre = <span class="number">0</span>,ans = nums[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">           pre = Math.<span class="built_in">max</span>(num,num+pre);</span><br><span class="line">           ans = Math.<span class="built_in">max</span>(ans,pre);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><br/><br/></p><h2 id="6、爬楼梯-✔"><a href="#6、爬楼梯-✔" class="headerlink" title="6、爬楼梯 ✔"></a>6、爬楼梯 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></p><p>通过观察可知该题为<strong>斐波那契数列</strong>，根据数列特性可写出递归代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>)+climbStairs(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样实现算法时空复杂度很高，并且有可能会导致栈溢出。</p><p>考虑使用<strong>正向循环（滚动数组）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">            sum = a+b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><br/><br/></p><h2 id="7、分割等和子集-✔"><a href="#7、分割等和子集-✔" class="headerlink" title="7、分割等和子集 ✔"></a>7、分割等和子集 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></p><blockquote><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/416-fen-ge-deng-he-zi-ji-dong-tai-gui-hu-csk5/">题解</a></p></blockquote><p><strong>思路：</strong></p><ol><li><p><strong>特例：</strong> 如果sum为奇数，那一定找不到符合要求的子集，返回False</p></li><li><p><strong>dp[j]含义：</strong> 有没有和为j的子集，有为True，没有为False</p></li><li><p><strong>初始化dp数组：</strong> 长度为target + 1，用于存储子集的和从0到target是否可能取到的情况。<br>比如和为0一定可以取到（也就是子集为空），那么dp[0] = True</p></li><li><p>接下来开始遍历nums数组，对遍历到的数nums[i]有两种操作，一个是选择这个数，一个是不选择这个数。</p><ul><li>不选择这个数：dp不变</li><li>选择这个数：dp中已为True的情况再加上nums[i]也为True。比如dp[0]已经为True，那么dp[0 + nums[i]]也是True</li></ul></li><li><p>在做出选择之前，我们先<strong>逆序遍历子集的和从nums[i]到target的所有情况</strong>，判断当前数加入后，dp数组中哪些和的情况可以从False变成True</p><p><font color = red>（为什么要逆序：是因为dp后面的和的情况是从前面的情况转移过来的，如果前面的情况因为当前nums[i]的加入变为了True，比如dp[0 + nums[i]]变成了True，那么因为一个数只能用一次，dp[0 + nums[i] + nums[i]]不可以从dp[0 + nums[i]]转移过来。如果非要正序遍历，必须要多一个数组用于存储之前的情况。而逆序遍历可以省掉这个数组）</font></p><p><strong>状态转移方程： dp[j] = dp[j] or dp[j - nums[i]]</strong></p><ul><li>如果不选择当前数，那么和为j的情况保持不变，dp[j]仍然是dp[j]，原来是True就还是True，原来是False也还是False；</li><li>如果选择当前数，那么如果j - nums[i]这种情况是True的话和为j的情况也会是True。比如和为0一定为True，只要 j - nums[i] == 0，那么dp[j]就变成了True<br/></li></ul><p>dp[j]和dp[j-nums[i]]只要有一个为True，dp[j]就变成True，因此用or连接两者</p></li></ol><ol start="6"><li>返回dp[target]</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 求出 sum </span></span><br><span class="line">        <span class="keyword">int</span> sum = Arrays.stream(nums).sum();;</span><br><span class="line">        <span class="comment">// sum为奇数 说明不能分割为两个相等的子集</span></span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= num; j--)&#123;</span><br><span class="line">                dp[j] = dp[j] || dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n * target)</li><li>空间复杂度：O(target)</li></ul><p><br/><br/></p><h2 id="8、目标和-✔"><a href="#8、目标和-✔" class="headerlink" title="8、目标和 ✔"></a>8、目标和 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/target-sum/">目标和</a></p><p>这道题用枚举递归也能做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        forSum(nums,S,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forSum</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> S,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="number">0</span> &amp;&amp; i == nums.length)&#123;</span><br><span class="line">            count ++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i == nums.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        forSum(nums,S + nums[i],i + <span class="number">1</span>);</span><br><span class="line">        forSum(nums,S - nums[i],i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是用递归时间复杂度是O(2^n)，其中n是数组nums的长度，时间复杂度为指数级别，效率比较差。</p><p>我们再看看dp：</p><blockquote><p><a href="https://leetcode-cn.com/problems/target-sum/solution/494-mu-biao-he-dong-tai-gui-hua-zhi-01be-78ll/">大佬题解</a></p></blockquote><p><strong>思路：</strong></p><ol><li>01背包问题是选或者不选，但本题是必须选，是选+还是选-。先将本问题转换为01背包问题。<br>假设<strong>所有符号为+的元素和为x，符号为-的元素和的绝对值是y</strong><br>我们想要的 S = 正数和 - 负数和 = x - y<br>而已知x与y的和是数组总和：sum = x + y<br>可以求出 x = (S + sum) / 2 = target<br>也就是我们要从nums数组里选出几个数，令其和为target<br>于是就转化成了求容量为target的01背包问题 =&gt; 要装满容量为target的背包，有几种方案</li><li>特例判断<br>如果S大于sum，不可能实现，返回0</li></ol><p><strong>如果x不是整数，也就是S + sum不是偶数，不可能实现，返回0</strong><br><strong>比如：</strong> nums: [1, 1, 1, 1, 1], S: 4  =&gt; <strong>无解</strong><br> 3. dp[j]代表的意义：填满容量为j的背包，有dp[j]种方法。因为填满容量为0的背包有且只有一种方法，所以dp[0] = 1<br> 4. 状态转移：dp[j] = dp[j] + dp[j - num]，<br>当前填满容量为j的包的方法数 = 之前填满容量为j的包的方法数 + 之前填满容量为j - num的包的方法数<br>也就是当前数num的加入，可以把之前和为j - num的方法数加入进来。<br> 5. 返回dp[target]</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 求出sum</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特例判断</span></span><br><span class="line">        <span class="keyword">if</span>(S &gt; sum || (sum + S) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = (sum + S) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 状态转移：dp[j] = dp[j] + dp[j - num]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= num; j--)&#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n * target)</li><li>空间复杂度：O(target)</li></ul><p><br/><br/><br/><br/></p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="1、链表逆序-反转链表-✔"><a href="#1、链表逆序-反转链表-✔" class="headerlink" title="1、链表逆序(反转链表) ✔"></a>1、链表逆序(反转链表) <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a><br><img src="https://img-blog.csdnimg.cn/20210305181444618.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>,cur = head;</span><br><span class="line">        ListNode temp = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = cur.next;     <span class="comment">//暂存后继节点</span></span><br><span class="line">            cur.next = pre;      <span class="comment">//更改指向</span></span><br><span class="line">            pre = cur;           <span class="comment">//更新pre</span></span><br><span class="line">            cur = temp;          <span class="comment">//访问下一节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(a+b),最差情况下（即 |a - b| = 1 , c=0 ），此时需遍历 a+b 个节点。</li><li>空间复杂度：O(1)</li></ul><p><br/><br/></p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">反转链表 II</a></p><p><strong>思路:</strong></p><ul><li>使用一个count记录，把要反转的链表拿出来</li><li>对链表进行反转</li><li>将反转的链表接回原链表<br><img src="https://img-blog.csdnimg.cn/20210329113315762.png" alt="在这里插入图片描述"></li></ul><p>结果看起来还行，但是自己思考的思路比较复杂，看了题解之后发现有更简洁的写法：</p><blockquote><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/yi-ge-neng-ying-yong-suo-you-lian-biao-t-vjx6/">题解</a></p></blockquote><p><strong>思路：</strong></p><ol><li>建一个虚拟头节点dummy，指向head节点</li><li>建立hh指针，一直往右移动至left的前一位置</li><li>使用a、b指针，将目标节点的next指针翻转</li><li>让hh.next（也就是left节点）的next指针指向b</li><li>让hh的next指针指向a</li><li>返回dummy.next</li></ol><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        r -= l;    <span class="comment">// 调整r指针 变成要被反转的链表的步数</span></span><br><span class="line">        ListNode hh = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l-- &gt; <span class="number">1</span>) hh = hh.next;     </span><br><span class="line">        <span class="comment">// ↑ 使hh指针在要被反转的前一个位置上,此时a在翻转链表的第一个元素,b在第二个</span></span><br><span class="line">        ListNode a = hh.next, b = a.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (r-- &gt; <span class="number">0</span>) &#123;   <span class="comment">// 每走一步 r--</span></span><br><span class="line">            ListNode tmp = b.next;  </span><br><span class="line">            b.next = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        hh.next.next = b;</span><br><span class="line">        hh.next = a;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="2、链表求交点-✔"><a href="#2、链表求交点-✔" class="headerlink" title="2、链表求交点 ✔"></a>2、链表求交点 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">相交链表</a><br><img src="https://img-blog.csdnimg.cn/20210312223719994.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针  在A的尾部衔接上B  两个指针一起走  </span></span><br><span class="line">        <span class="comment">//最后如果相同就返回A  不相同走到最后 A B均为null</span></span><br><span class="line">        ListNode A = headA, B = headB;</span><br><span class="line">        <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">            A = A != <span class="keyword">null</span> ? A.next : headB;</span><br><span class="line">            B = B != <span class="keyword">null</span> ? B.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//另外一个版本的双指针  如果A比B长 就先让A走(A-B)步 再双指针遍历 </span></span><br><span class="line">        <span class="comment">//如果有相同点返回A 没有相同点返回null   比较麻烦</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul><p><br/><br/></p><h2 id="3、链表求环-环形链表-✔"><a href="#3、链表求环-环形链表-✔" class="headerlink" title="3、链表求环(环形链表) ✔"></a>3、链表求环(环形链表) <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></p><p>同样使用双指针求解,快慢指针一起遍历链表,如果两指针相遇则说明存在环,反之则不存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;  <span class="comment">//快指针一次走两步</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow == <span class="keyword">null</span> ? <span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 是链表中的节点数。</li><li>空间复杂度：O(1),我们只使用了两个指针的额外空间。</li></ul><p><br/><br/></p><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表II</a></p><p><br/><br/></p><h2 id="4、复杂链表的复制-✔"><a href="#4、复杂链表的复制-✔" class="headerlink" title="4、复杂链表的复制 ✔"></a>4、复杂链表的复制 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制</a></p><p><strong>思路:</strong></p><ol><li>使用HashMap 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射<br>即 ==map.put(cur, new Node(cur.val));==</li><li>构建新链表的 next 和 random 指向</li><li>最后直接返回新链表的头节点即可</li></ol><p><strong>代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> Node(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">// 构建新链表的 next 和 random 指向</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度：O(N)，两轮遍历链表，使用 O(N)时间</li><li>空间复杂度：O(N)，哈希表使用了线性大小的额外空间</li></ul><p><br/><br/></p><h2 id="5、两个排序链表的归并-✔"><a href="#5、两个排序链表的归并-✔" class="headerlink" title="5、两个排序链表的归并 ✔"></a>5、两个排序链表的归并 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/">合并两个有序链表</a><br><img src="https://img-blog.csdnimg.cn/20210313145950248.png" alt="递归调用图解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归调用解法</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1 == <span class="keyword">null</span> ? l2:l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="6、k个排序链表的归并-✔"><a href="#6、k个排序链表的归并-✔" class="headerlink" title="6、k个排序链表的归并 ✔"></a>6、k个排序链表的归并 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并k个升序链表</a></p><p><strong>偷懒暴力解决法:</strong></p><p>能想到的最朴素的方法就是循环,用一个ans作为主链,k个链表作为副链 循环两两合并:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//最朴素的方法</span></span><br><span class="line">       ListNode ans = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; ++i) &#123;</span><br><span class="line">           ans = mergeTwoLists(ans, lists[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//递归调用解法</span></span><br><span class="line">       <span class="keyword">if</span>(l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1 == <span class="keyword">null</span> ? l2:l1;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">           l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>空间复杂度: O(1) </li><li>时间复杂度: O(n*k^2)</li></ul><p><strong>结果:</strong><br><img src="https://img-blog.csdnimg.cn/20210313152416794.png" alt="在这里插入图片描述"></p><p><br/><br/></p><p><strong>分治法:</strong></p><p>其实我第一个想到的是分治法,但是具体实现并不简单,看了题解之后的答案:</p><p><strong>分治法图解 :</strong><br><img src="https://img-blog.csdnimg.cn/20210313153212351.png" alt="在这里插入图片描述"></p><p><strong>代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// ↓ 最重要的是这一步,方法递归方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists, l, mid), <span class="built_in">merge</span>(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归调用解法</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == null || l2 == null) <span class="keyword">return</span> l1 == null ? l2:l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = <span class="built_in">mergeTwoLists</span>(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = <span class="built_in">mergeTwoLists</span>(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结果:</strong><br><img src="https://img-blog.csdnimg.cn/20210331113541736.png" alt="在这里插入图片描述"><br><strong>复杂度分析:</strong><br><img src="https://img-blog.csdnimg.cn/20210331113821757.png" alt="在这里插入图片描述"></p><p><br/><br/><br/><br/></p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="1、旋转数组的查找-✔"><a href="#1、旋转数组的查找-✔" class="headerlink" title="1、旋转数组的查找 ✔"></a>1、旋转数组的查找 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></p><p>排序数组的旋转规律有迹可循，我们可以通过判断左边半个数组的端点 nums[left] 与 nums[mid] 的关系可以得出左边是否是有序的，如果左半数组有序则右半数组无序，反之亦然</p><p>通过思考可以写出以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]==target ? <span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.length-<span class="number">1</span>;   <span class="comment">//定义两个端点</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//判断中点左边是否有序,如果有序则右边无序,如果无序则右边有序</span></span><br><span class="line">            <span class="comment">// 1.左边有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt;=nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;=nums[l] &amp;&amp; target&lt;nums[mid])&#123;</span><br><span class="line">                    <span class="comment">// target在左</span></span><br><span class="line">                    r = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// target在右</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 2.右边有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid] &amp;&amp; target&lt;=nums[r])&#123;</span><br><span class="line">                    <span class="comment">// target在右</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// target在左</span></span><br><span class="line">                    r = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br/><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组II</a><br>与<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a>相比，本题中的 nums  <strong>可能包含重复元素</strong>，所以我们需要考虑的情况多了一种：</p><ol><li>[10111] 和 [11101] 这种。此种情况下 nums[left] == nums[mid]，分不清到底是前面有序还是后面有序，此时 left++ 即可。相当于去掉一个重复的干扰项</li><li>依旧判断中点左边是否有序，如果有序则右边无序，如果无序则右边有序</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]==target ? <span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义指针</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span> , r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r-l)&gt;&gt;<span class="number">1</span>);   <span class="comment">//l+(r-l)是为了防止溢出 使用&gt;&gt;1是因为位运算速度更快</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] == nums[mid] &amp;&amp; l&lt;nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                l++;                         <span class="comment">//将l指针移到没有重复元素的位置</span></span><br><span class="line">                <span class="keyword">continue</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断中点左边是否有序,如果有序则右边无序,如果无序则右边有序</span></span><br><span class="line">            <span class="comment">// 1.左边有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt;=nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;=nums[l] &amp;&amp; target&lt;nums[mid])&#123;</span><br><span class="line">                    <span class="comment">// target在左</span></span><br><span class="line">                    r = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// target在右</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 2.右边有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid] &amp;&amp; target&lt;=nums[r])&#123;</span><br><span class="line">                    <span class="comment">// target在右</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// target在左</span></span><br><span class="line">                    r = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br/><p><a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/">搜索旋转数组</a></p><p>这题与<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a>的差别在于<strong>数组不止被旋转了一次，并且还会出现重复元素</strong><br>但实际上旋转多次与旋转一次对于这道题没有什么区别，所以只需要解决这道题<strong>重复元素输出索引值最小</strong>的问题就可以了</p><p>综上，我们需要考虑的情况：</p><ol><li>当nums[mid] == target 时，我们不能确定mid前面是否有重复元素，所以我们将右指针right=mid，再进行循环去判断即可</li><li>[10111] 和 [11101] 这种。此种情况下 nums[left] == nums[mid]，分不清到底是前面有序还是后面有序，此时 left++ 即可。相当于去掉一个重复的干扰项</li><li>依旧判断中点左边是否有序，如果有序则右边无序，如果无序则右边有序</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义左右指针</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[l] == target) <span class="keyword">return</span> l;</span><br><span class="line">            <span class="comment">//当mid==target时要判断它前面有没有重复元素  直接让r=mid继续循环</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 排除重复干扰</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] == nums[mid])&#123;</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左边有序的情况</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="comment">//落在左边</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[l] &amp;&amp; target &lt;= nums[mid])&#123;</span><br><span class="line">                    r = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//落在右边</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;   <span class="comment">//右边有序的情况</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[mid] &amp;&amp; target &lt;= nums[l])&#123;</span><br><span class="line">                    <span class="comment">//落在右边</span></span><br><span class="line">                    l = mid+<span class="number">1</span>; </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//落在左边</span></span><br><span class="line">                    r = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a></p><p>这题不再给定target，而是要求我们求出nums中的最小值，我们依旧可以判断出旋转数组是在中点左边有序或在中点右边有序，所以我们只需要<strong>找出最小值</strong>即可</p><p>综上，我们要做的有：</p><ol><li><p>判断数组中点左边或右边有序</p></li><li><p>如果是左边有序，判断端点 ：</p><p>  nums[left] &lt; nums[right] 说明数组完全升序，直接输出 nums[left]<br>  nums[left] &gt;= nums[right] 说明有更小的数存在于右半数组，将 l = mid+1 继续下次循环</p></li><li><p>如果右边有序：<br> nums[mid] &lt; nums[mid-1] 直接输出nums[mid]<br> nums[mid] &gt;= nums[mid-1]   说明有更小的数存在于右半数组，将 r = mid-1 继续下次循环</p></li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义左右指针</span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+((r-l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//左边有序</span></span><br><span class="line">        <span class="keyword">if</span>(nums[l] &lt;= nums[mid])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt; nums[r]) <span class="keyword">return</span> nums[l];</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//右边有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid-<span class="number">1</span>]) <span class="keyword">return</span> nums[mid];</span><br><span class="line">            <span class="keyword">else</span> r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><p><strong>困难题:</strong> <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值 II</a></p><p>这道题也是要求我们求出数组中的最小值，但是其中可能会<strong>存在重复元素</strong></p><p>我们需要考虑的情况：</p><ol><li><p>当nums[left] == nums[mid] 且 <strong>left != mid</strong> 时，证明左边数组有重复元素，排除重复元素干扰后          再进行循环即可</p></li><li><p>如果是左边有序，判断端点 ：       </p><p>  nums[left] &lt; nums[right] 说明数组完全升序，直接输出 nums[left]<br>  nums[left] &gt;= nums[right] 说明有更小的数存在于右半数组，将 l = mid+1 继续下次循环</p></li><li><p>如果右边有序：<br> nums[mid] &lt; nums[mid-1] 直接输出nums[mid]<br> nums[mid] &gt;= nums[mid-1]   说明有更小的数存在于右半数组，将 r = mid-1 继续下次循环</p></li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义左右指针</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+((r-l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//排除重复项干扰  l!=mid是为了不要误伤当length==2的情况</span></span><br><span class="line">            <span class="keyword">if</span>(l != mid &amp;&amp; nums[l] == nums[mid])&#123;</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左边有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l] &lt; nums[r]) <span class="keyword">return</span> nums[l];</span><br><span class="line">                <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//右边有序</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; nums[mid-<span class="number">1</span>]) <span class="keyword">return</span> nums[mid];</span><br><span class="line">                <span class="keyword">else</span> r = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="2、区间查找-✔"><a href="#2、区间查找-✔" class="headerlink" title="2、区间查找 ✔"></a>2、区间查找<font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></p><p><strong>思路:</strong></p><ul><li>使用二分查找，分别遍历一次nums，找出第一个位置和最后一个位置</li></ul><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] <span class="built_in">searchRange</span>(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first = <span class="built_in">findFirstPosition</span>(nums, target);</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="number">-1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> last = <span class="built_in">findLastPosition</span>(nums, target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;first, last&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirstPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 小于一定不是解</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="comment">// 因为在找第一个位置，所以下一轮搜索区间是 [left, mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// nums[mid] &gt; target，下一轮搜索区间是 [left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLastPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="comment">// 因为在找最后的位置，所以下一轮搜索区间是 [mid, right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// nums[mid] &lt; target，下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(log N)，这里 N 是数组的长度，两个子问题都是二分查找，因此时间复杂度为对数级别</li><li>空间复杂度：O(1)，只使用了常数个数的辅助变量、指针</li></ul><p><br/><br/></p><h2 id="3、逆序数"><a href="#3、逆序数" class="headerlink" title="3、逆序数 *"></a>3、逆序数<font color=red> *</font></h2><p><strong>困难题：</strong> <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></p><p><br/><br/></p><h2 id="4、二叉查找树的编码与解码-✔"><a href="#4、二叉查找树的编码与解码-✔" class="headerlink" title="4、二叉查找树的编码与解码  ✔"></a>4、二叉查找树的编码与解码 <font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">序列化和反序列化二叉搜索树</a></p><p><strong>代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边界判断，如果为空就返回一个字符串&quot;#&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> root.val + <span class="string">&quot;,&quot;</span> + serialize(root.left) + <span class="string">&quot;,&quot;</span> + serialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把字符串data以逗号&quot;,&quot;拆分，拆分之后存储到队列中</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> helper(queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//出队</span></span><br><span class="line">        String sVal = queue.poll();</span><br><span class="line">        <span class="comment">//如果是&quot;#&quot;表示空节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;#&quot;</span>.equals(sVal))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//否则创建当前节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(sVal));</span><br><span class="line">        <span class="comment">//分别创建左子树和右子树</span></span><br><span class="line">        root.left = helper(queue);</span><br><span class="line">        root.right = helper(queue);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="5、插入位置-✔"><a href="#5、插入位置-✔" class="headerlink" title="5、插入位置  ✔"></a>5、插入位置 <font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置</a></p><p><strong>思路:</strong> 二分查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度:O(logN)</li><li>空间复杂度:O(1)</li></ul><p><br/><br/><br/><br/></p><h1 id="栈-队列-堆"><a href="#栈-队列-堆" class="headerlink" title="栈 队列 堆"></a>栈 队列 堆</h1><h2 id="1、使用队列实现栈-✔"><a href="#1、使用队列实现栈-✔" class="headerlink" title="1、使用队列实现栈  ✔"></a>1、使用队列实现栈 <font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">用队列实现栈</a></p><p><strong>思路：</strong></p><ul><li>使用基本队列， 每当push新元素，如果队列中有元素，则出队后再重新入队，达到后入先出的效果</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/99f0db5aac0299ed4eb63a256fc369c3.gif#pic_center" alt="在这里插入图片描述"></p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.<span class="built_in">size</span>();</span><br><span class="line">        queue.<span class="built_in">offer</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            queue.<span class="built_in">offer</span>(queue.<span class="built_in">poll</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.<span class="built_in">poll</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.<span class="built_in">isEmpty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="2、使用栈实现队列-✔"><a href="#2、使用栈实现队列-✔" class="headerlink" title="2、使用栈实现队列  ✔"></a>2、使用栈实现队列 <font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">用栈实现队列</a></p><p><strong>思路：</strong></p><ul><li>定义两个栈来模拟队列</li></ul><p><img src="https://img-blog.csdnimg.cn/20210403170101754.png" alt="在这里插入图片描述"></p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先倒一次</span></span><br><span class="line">        <span class="keyword">while</span>(!stack1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            stack2.<span class="built_in">push</span>(stack1.<span class="built_in">pop</span>()); </span><br><span class="line">        &#125;</span><br><span class="line">        stack1.<span class="built_in">push</span>(x);  <span class="comment">// 在空的stack1压入元素</span></span><br><span class="line">        <span class="comment">// 再倒一次  实现先进先出</span></span><br><span class="line">        <span class="keyword">while</span>(!stack2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            stack1.<span class="built_in">push</span>(stack2.<span class="built_in">pop</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="3、包含min函数的栈-✔"><a href="#3、包含min函数的栈-✔" class="headerlink" title="3、包含min函数的栈  ✔"></a>3、包含min函数的栈 <font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">包含min函数的栈</a></p><p><strong>思路：</strong></p><ul><li>使用辅助栈，当入栈元素比辅助栈栈顶小或辅助栈为空时将元素压入辅助栈</li><li>这里有一个需要注意的地方：<strong>当入栈元素比辅助栈栈顶元素大时，我们选择不压入该元素，但是应该再次压入当前辅助栈栈顶元素，防止辅助栈提前被取空</strong><br><img src="https://img-blog.csdnimg.cn/20210403230516186.png" alt="在这里插入图片描述"></li></ul><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    Stack&lt;Integer&gt; min;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        min = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="comment">// if(min.size() == 0 || x &lt; min.peek()) min.push(x);</span></span><br><span class="line">        <span class="comment">// else min.push(min.peek());</span></span><br><span class="line">        min.<span class="built_in">push</span>(Math.<span class="built_in">min</span>(min.<span class="built_in">peek</span>(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        min.<span class="built_in">pop</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="4、简单的计算器"><a href="#4、简单的计算器" class="headerlink" title="4、简单的计算器 *"></a>4、简单的计算器<font color=red> *</font></h2><p><strong>困难题:</strong><a href="https://leetcode-cn.com/problems/basic-calculator/">基本计算器</a></p><p><br/><br/></p><h2 id="5、数组中第k大的数-✔"><a href="#5、数组中第k大的数-✔" class="headerlink" title="5、数组中第k大的数  ✔"></a>5、数组中第k大的数 <font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></p><p><strong>思路:</strong></p><ul><li>主要是考手写快排，要特别注意边界条件</li><li>下面的代码是一个快排模板，也可以再精简</li></ul><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,<span class="number">0</span>,nums.length<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     快排</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> leftBound,<span class="keyword">int</span> rightBound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftBound &gt;= rightBound) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="built_in">partition</span>(nums,leftBound,rightBound);</span><br><span class="line">        <span class="comment">// 递归过程</span></span><br><span class="line">        <span class="built_in">quickSort</span>(nums,leftBound,mid<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,mid+<span class="number">1</span>,rightBound);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分区排序 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> leftBound,<span class="keyword">int</span> rightBound)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[rightBound];</span><br><span class="line">        <span class="keyword">int</span> l = leftBound,r = rightBound <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r &amp;&amp; nums[l] &lt;= pivot) l++;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r &amp;&amp; nums[r] &gt; pivot) r--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l &lt; r) <span class="built_in">swap</span>(nums,l,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把轴放到该放的位置</span></span><br><span class="line">        <span class="keyword">if</span>(pivot &lt; nums[l]) <span class="built_in">swap</span>(nums,l,rightBound);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] n,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = n[i];</span><br><span class="line">        n[i] = n[j];</span><br><span class="line">        n[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：最好情况O（N*logN），最差情况（即数组完全顺序或完全逆序，并且取的pivot并不随机导致）为O（N^2）</li><li>空间复杂度：如果考虑递归占用一定的临时空间则为O（logN），如果不考虑则为O（1）</li></ul><p><br/><br/></p><h2 id="6、寻找中位数-✔"><a href="#6、寻找中位数-✔" class="headerlink" title="6、寻找中位数 ✔"></a>6、寻找中位数 <font color=green>✔</font></h2><p><strong>困难题:</strong> <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></p><p><strong>思路：</strong></p><p>简化版本的归并排序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//定义数组nums1的指针</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;<span class="comment">//定义数组nums2的指针</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;<span class="comment">//定义数组nums3的指针</span></span><br><span class="line">        <span class="keyword">int</span> [] nums3 = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length+nums2.length];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt;= nums2[j])&#123;</span><br><span class="line">                nums3[k] = nums1[i];</span><br><span class="line">                k++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                nums3[k] = nums2[j];</span><br><span class="line">                k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length) nums3[k++] = nums1[i++];<span class="comment">//剩余nums1处理</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length) nums3[k++] = nums2[j++];<span class="comment">//剩余nums2处理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums3.length % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">double</span>)(nums3[nums3.length / <span class="number">2</span>] + nums3[(nums3.length / <span class="number">2</span>) - <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">double</span>)nums3[nums3.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/><br/><br/></p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="1、最长回文串-✔"><a href="#1、最长回文串-✔" class="headerlink" title="1、最长回文串 ✔"></a>1、最长回文串 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/longest-palindrome/">最长回文串</a></p><p>这道题并不需要我们输出最长回文串，只需要输出最长回文串的长度，所以可以考虑使用HashMap建立映射，看了题解后发现可以用int数组来存储各个字母出现的次数，<strong>所以我们使用了一个长度为 128 的数组，存储每个字符出现的次数，这是因为字符的 ASCII 值的范围为 [0, 128)。</strong></p><p><strong>我们需要考虑的有：</strong></p><ol><li>遍历 s.toCharArray() ，存储每个字母出现的次数</li><li>遍历数组，记录奇数出现的次数count</li><li>当 count ==  0 时直接返回结果，当 count !=  0 时说明有奇数，用s.length - count 后再+1（可以让一个奇数存在在回文串的中间）</li></ol><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];  <span class="comment">//我们使用了一个长度为 128 的数组，存储每个字符出现的次数，</span></span><br><span class="line">                                   <span class="comment">// 这是因为字符的 ASCII 值的范围为 [0, 128)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            arr[c]++;              <span class="comment">//存储每个字母出现的次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            count += (i % <span class="number">2</span>);       <span class="comment">//存储奇数出现的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span> ? s.length() : (s.length() - count + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="2、重复的DNA序列-✔"><a href="#2、重复的DNA序列-✔" class="headerlink" title="2、重复的DNA序列 ✔"></a>2、重复的DNA序列 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">重复的DNA序列</a></p><p>这道题暴力循环肯定超时，可以考虑使用set，每遍历一组就将其放入，在加入之前判断 HashSet 中是否存在，如果存在就说明和之前的发生重复，就把它加到结果中。从而我们可以减少一层循环。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        Set&lt;String&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len - <span class="number">10</span>; i++) &#123;</span><br><span class="line">        String key = s.substring(i, i + <span class="number">10</span>);</span><br><span class="line">         <span class="comment">//之前是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (set.contains(key)) &#123;</span><br><span class="line">            res.add(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.add(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(res);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="3、最小窗口子串"><a href="#3、最小窗口子串" class="headerlink" title="3、最小窗口子串     *"></a>3、最小窗口子串    <font color=red> *</font></h2><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></p><p><strong>本题思路：</strong></p><p><br/><br/></p><h2 id="4、无重复字符的最长子串-✔"><a href="#4、无重复字符的最长子串-✔" class="headerlink" title="4、无重复字符的最长子串 ✔"></a>4、无重复字符的最长子串 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长字串</a></p><p><strong>本题思路:</strong></p><ol><li>使用滑动窗口遍历整个字符串</li><li>没有发现重复元素时，固定左指针，将右指针的字符添加到Hashset，并让右指针+1</li><li>每次当右指针发现重复元素时，固定右指针，将左指针的字符从Hashset中remove，再让左指针+1</li><li>每次发现重复字符时，输出 res = Math.max(res,r-l) ，但此处需要进行边界处理，当 r = s.length() -1 并且该字符没有重复时，直接 return res = Math.max(res,r-l+1);</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; map = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(r &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//判断--&gt;右指针右移--&gt;左指针右移</span></span><br><span class="line">            <span class="keyword">if</span>(!map.contains(s.charAt(r))) &#123;</span><br><span class="line">                <span class="keyword">if</span>(r == s.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> res = Math.max(res,r-l+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                map.add(s.charAt(r++));     <span class="comment">//右指针向右移动，先存入当前右指针的字符</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max(res,r-l);    </span><br><span class="line">                map.remove(s.charAt(l++));    <span class="comment">//左指针向右移动,移除当前左指针的字符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 是字符串的长度。右指针会遍历整个字符串一次。</li><li>空间复杂度：O(∣Σ∣)，其中 Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0,128) 内的字符，即 ∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。</li></ul><p><br/><br/></p><h2 id="5、同字符词语分组-✔"><a href="#5、同字符词语分组-✔" class="headerlink" title="5、同字符词语分组 ✔"></a>5、同字符词语分组 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/group-anagrams/">字母异位词分组</a></p><blockquote><p><a href="https://leetcode-cn.com/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/">题解</a></p></blockquote><p><strong>思路:</strong></p><ul><li>先将字符串转换为char数组</li><li>使用数组的sort方法将字母进行排序</li><li>因为排序后的顺序相同，我们可以将排序后的字符串作为map的key，如果key相同那最后存入的位置一定相同</li></ul><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="built_in">groupAnagrams</span>(String[] strs) &#123;</span><br><span class="line">        <span class="comment">// 由于互为字母异位词的两个字符串包含的字母相同，</span></span><br><span class="line">        <span class="comment">// 因此对两个字符串分别进行排序之后得到的字符串一定是相同的，</span></span><br><span class="line">        <span class="comment">// 故可以将排序之后的字符串作为哈希表的键。 </span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] array = str.<span class="built_in">toCharArray</span>();</span><br><span class="line">            Arrays.<span class="built_in">sort</span>(array);</span><br><span class="line">            String key = <span class="keyword">new</span> <span class="built_in">String</span>(array);</span><br><span class="line">            List&lt;String&gt; list = map.<span class="built_in">getOrDefault</span>(key, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            list.<span class="built_in">add</span>(str);</span><br><span class="line">            map.<span class="built_in">put</span>(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.<span class="built_in">values</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/><br/><br/></p><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="1、分糖果-✔"><a href="#1、分糖果-✔" class="headerlink" title="1、分糖果 ✔"></a>1、分糖果 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/distribute-candies/">分糖果</a></p><p>这道题需要把最多种类的糖果分给妹妹，弟弟可以忽略，其实就是相当于从数组中取出1/2最多种类的糖果，糖果种类可以分成以下情况：</p><ol><li>糖果种类 count &gt;= n/2，这种情况妹妹可以得到最多的 n/2 种糖果</li><li>糖果种类 count &lt; n/2，这种情况妹妹只能得到 count 种糖果</li></ol><p><strong>方法一：</strong><br>我们可以考虑通过 Arrays.sort() 来对数组进行排序，之后遍历数组比较相邻的两个数组，且当 count &gt;= n/2 时我们可以提前中止遍历，输出 count</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span>[] candies)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排序法</span></span><br><span class="line">        Arrays.sort(candies);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; candies.length &amp;&amp; count &lt; candies.length / <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (candies[i] &gt; candies[i - <span class="number">1</span>])</span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度：O(n log n)，其中排序方法需要O(log n)时间</li><li>空间复杂度：O(1)</li></ul><br/><p><strong>方法二：</strong><br>找到唯一元素数量的另一种方法是遍历给定 candies 数组的所有元素，并继续将元素放入集合中。通过集合的属性，它将只包含唯一的元素。最后，我们可以计算集合中元素的数量，例如 count。要返回的值将再次由  min(count,n/2) 给出，如前面的方法所述。其中 n 表示 candies 数组的大小。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set集合</span></span><br><span class="line">        HashSet &lt; Integer &gt; set = <span class="keyword">new</span> HashSet &lt; &gt; ();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy: candies) &#123;</span><br><span class="line">            set.add(candy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(set.size(), candies.length / <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)，最坏情况下，set的大小为n</li></ul><p><br/><br/></p><p><a href="https://leetcode-cn.com/problems/distribute-candies-to-people/">分糖果 II</a></p><p>这道题是那candies个糖果分给 n个人，如分给四个人：第一轮分 [1,2,3,4]，第二轮 [5,6,7,8] ，以此类推。</p><p>考虑直接循环遍历数组，每一轮发给当前小朋友 <strong>i</strong> 的糖果数为 <strong>i+1+(round-1)×n</strong> ，在每一轮结束后round+1</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] distributeCandies(<span class="keyword">int</span> candies, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> round = <span class="number">1</span>;        <span class="comment">//定义轮数</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">while</span>(candies&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> num = i+<span class="number">1</span>+(round-<span class="number">1</span>)*n;</span><br><span class="line">                <span class="keyword">if</span>(candies &gt;= num)&#123;</span><br><span class="line">                    candies -= num;</span><br><span class="line">                    res[i] += num;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i] += candies;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            round++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(s)，s为发完糖果要循环数组的步数</li><li>空间复杂度：O(1)</li></ul><p><br/><br/></p><h2 id="2、跳跃游戏1-2-✔"><a href="#2、跳跃游戏1-2-✔" class="headerlink" title="2、跳跃游戏1 2 ✔"></a>2、跳跃游戏1 2 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏 I</a><br>给定一个非负整数数组nums，数组中的每个元素代表你在该位置可以跳跃的最大长度，判断是否能够到达最后一个下标。</p><br/><p><strong>方法一：扫描遍历</strong></p><p>这道题如果数组都不为0，则我们一定可以到达最后一个下标，如果存在0，那么需要存在最大长度能够越过这个0的数字，否则无法到达。</p><p>综上，我们需要注意的有：</p><ol><li>除最后一个元素外，如果所有元素都不为0，那么一定可以走到最后</li><li>从后往前扫描数组，当遇到0时，扫描当前下标 <strong>j</strong> 前的元素，判断是否存在 <strong>i</strong> 使得 nums[i] &gt;= j-i+1 （越过j这个0元素）</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == <span class="number">0</span> &amp;&amp; j != nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> i=j;</span><br><span class="line">                <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i] &gt;= j-i+<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br/><p><strong>方法二：贪心算法</strong></p><p>如果这道题能够想到当一个位置可达时，该位置左边的所有位置都可达，就不难想到我们可以依次遍历数组中的每一个位置，并实时维护 <strong>最远可以到达的位置 k</strong> 。对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用  x+nums[x] 更新 k</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>,n = nums.length;    <span class="comment">//k为最大可达距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= k) &#123;  <span class="comment">//如果当前位置i可达</span></span><br><span class="line">                k = Math.max(k, i + nums[i]);   <span class="comment">//判断 更新k i为当前位置,nums[i]为当前位置能走的步数,</span></span><br><span class="line">                                                <span class="comment">// i+nums[i]就是当前位置可达的最大距离</span></span><br><span class="line">                <span class="keyword">if</span> (k &gt;= n - <span class="number">1</span>)  <span class="keyword">return</span> <span class="keyword">true</span>;   <span class="comment">//如果k已经能够达到最后一个下标,提前返回,减少循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br/><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></p><p>给定一个非0数组，即一定可以到达数组最后一个位置，现在要求我们求出跳到最后的位置需要的最少次数，使用贪心算法的核心思路：<strong>反向搜索最远能抵达position的位置，position从最后一个位置开始，即可求出需要的最少步数</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> position = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">                <span class="comment">// 搜索最远能跳到position的位置</span></span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt;= position) &#123;</span><br><span class="line">                    position = i;</span><br><span class="line">                    steps++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O（N）</li><li>空间复杂度：O（1）</li></ul><p><br/><br/></p><h2 id="3、剪绳子-✔"><a href="#3、剪绳子-✔" class="headerlink" title="3、剪绳子 ✔"></a>3、剪绳子 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剪绳子</a></p><p>这道题要求我们将长度为 n 的绳子剪为 m 段(m &gt; 1)，看了题解之后的答案：</p><p>我们可以使用贪心算法，核心思路是：<strong>尽可能把绳子分为长度为3的小段，这样乘积最大</strong></p><blockquote><p>为什么长度为3的小段乘积最大：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/">看这里</a></p></blockquote><p>明确了任务之后，我们要做的步骤如下：</p><ol><li>考虑特殊情况：当 n == 2 时 直接返回1，当n == 3 时直接返回2，合起来为当 n &lt; 4 时返回 n - 1，当 n == 4 时返回4</li><li>n &gt; 4 时，每次循环都将 n - 3 ，再将 res × 3 ，返回结果 res × 剩下的不足3的 n</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">4</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">        res *= <span class="number">3</span>;</span><br><span class="line">        n -= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><br/><br/></p><h2 id="4、最优加油方法"><a href="#4、最优加油方法" class="headerlink" title="4、最优加油方法 *"></a>4、最优加油方法<font color=red> *</font></h2><p><a href="https://leetcode-cn.com/problems/minimum-number-of-refueling-stops/">最低加油次数</a></p><p><br/><br/></p><h2 id="5、移除k个数字-✔"><a href="#5、移除k个数字-✔" class="headerlink" title="5、移除k个数字 ✔"></a>5、移除k个数字 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/remove-k-digits/">移除k个数字</a></p><blockquote><p><a href="https://leetcode-cn.com/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5/">题解</a></p></blockquote><p><strong>思路：</strong></p><ul><li>使用单调栈存储每个取出的数字，当这个 <strong>取出的数字比栈顶的数字大</strong> 并且 <strong>要删除的数字k不为0</strong> 时，替换栈顶的元素</li></ul><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == k) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用单调栈存储</span></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] c = num.<span class="built_in">toCharArray</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.<span class="built_in">isEmpty</span>() &amp;&amp; c[i] &lt; stack.<span class="built_in">peekLast</span>() &amp;&amp; k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">removeLast</span>();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.<span class="built_in">addLast</span>(c[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line">        boolean firstZero = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 此处 !=k 是为了防止当数字为单调递增或部分单调递增的情况时，</span></span><br><span class="line">        <span class="comment">// k不会减到0，此时要裁剪字符串</span></span><br><span class="line">        <span class="keyword">while</span>(stack.<span class="built_in">size</span>() != k)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(firstZero &amp;&amp; stack.<span class="built_in">peekFirst</span>() == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">removeFirst</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            firstZero = <span class="literal">false</span>;   <span class="comment">// 不管首位是不是0 第一次循环以后设置为false</span></span><br><span class="line">            res.<span class="built_in">append</span>(stack.<span class="built_in">removeFirst</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">length</span>() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : res.<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，其中 nn 为字符串的长度。尽管存在嵌套循环，但内部循环最多运行 k 次。由于 0 &lt; k ≤ n，主循环的时间复杂度被限制在 2n 以内。对于主循环之外的逻辑，它们的时间复杂度是 O(n)，因此总时间复杂度为 O(n)。</li><li>空间复杂度：O(n)，栈存储数字需要线性的空间。</li></ul><p><br/><br/><br/><br/></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="1、二叉树转链表-✔"><a href="#1、二叉树转链表-✔" class="headerlink" title="1、二叉树转链表 ✔"></a>1、二叉树转链表 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树转链表</a></p><p><strong>递归分治解法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//思路:使用递归  分治法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span> &amp;&amp; root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode temp = root.left;  <span class="comment">//定义temp存储root.left</span></span><br><span class="line">            <span class="comment">//用于待会遍历到最后 接上root.right</span></span><br><span class="line">            flatten(root.right);</span><br><span class="line">            flatten(root.left);</span><br><span class="line">            <span class="keyword">while</span>(temp.right != <span class="keyword">null</span>) temp = temp.right;  <span class="comment">//开始遍历</span></span><br><span class="line">            temp.right = root.right;   <span class="comment">//接上</span></span><br><span class="line">            root.right = root.left;    <span class="comment">//全部接在右节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            flatten(root.right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            flatten(root.left);</span><br><span class="line">            root.right = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>空间复杂度: O(H)  H为树的高度，空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 (logN)。</li><li>时间复杂度: O(N)  </li></ul><p><br/><br/></p><h2 id="2、路径之和-✔"><a href="#2、路径之和-✔" class="headerlink" title="2、路径之和 ✔"></a>2、路径之和 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/path-sum/">路径总和I</a></p><p>这个题比较简单,很容易就想到了递归解法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//思路:递归</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.val==targetSum;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度: O(N)  ，其中 N 是树的节点数。对每个节点访问一次。</li><li>空间复杂度: O(H)  H为树的高度，空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 (logN)。     </li></ul><br/><p><a href="https://leetcode-cn.com/problems/path-sum-ii/">路径总和II</a></p><p>比较难的是这道题 要求我们将所有符合的路径存在数组中返回，考虑使用回溯法(深度优先):</p><p><strong>代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="built_in">pathSum</span>(TreeNode root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> res;</span><br><span class="line">        path.<span class="built_in">add</span>(root.val);</span><br><span class="line">        <span class="built_in">backtracking</span>(root,targetSum,root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为有负数,所以得将sum参数加上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(TreeNode root,<span class="keyword">int</span> targetSum,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有答案时还要判断是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(sum == targetSum &amp;&amp; root.left == null &amp;&amp; root.right == null)&#123;</span><br><span class="line">            res.<span class="built_in">add</span>(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != null)&#123;</span><br><span class="line">            path.<span class="built_in">addLast</span>(root.left.val);</span><br><span class="line">            <span class="built_in">backtracking</span>(root.left,targetSum,sum + root.left.val);</span><br><span class="line">            path.<span class="built_in">removeLast</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != null)&#123;</span><br><span class="line">            path.<span class="built_in">addLast</span>(root.right.val);</span><br><span class="line">            <span class="built_in">backtracking</span>(root.right,targetSum,sum + root.right.val);</span><br><span class="line">            path.<span class="built_in">removeLast</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了官方题解以后发现自己的代码写的很繁琐，修改后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="built_in">pathSum</span>(TreeNode root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(root,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">addLast</span>(root.val);</span><br><span class="line">        sum -= root.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有答案时还要判断是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span> &amp;&amp; root.left == null &amp;&amp; root.right == null)&#123;</span><br><span class="line">            res.<span class="built_in">add</span>(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="comment">// return;</span></span><br><span class="line">            <span class="comment">// 这里不能加return 如果加了return就会影响弹栈</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtracking</span>(root.left,sum);</span><br><span class="line">        <span class="built_in">backtracking</span>(root.right,sum);</span><br><span class="line">        path.<span class="built_in">removeLast</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="3、最近的公共祖先-✔"><a href="#3、最近的公共祖先-✔" class="headerlink" title="3、最近的公共祖先 ✔"></a>3、最近的公共祖先 <font color=green>✔</font></h2><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉搜索树最近的公共祖先</a></p><p>由于是二叉搜索树，左子树的最大值永远小于根节点，右子树的最小值永远大于根节点，很容易想到判断p、q两点的落点，再进行递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.val&gt;root.val &amp;&amp; q.val&gt;root.val)    <span class="comment">//都在右子树  递归右子树</span></span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(p.val&lt;root.val &amp;&amp; q.val&lt;root.val)     <span class="comment">//都在左子树   递归左子树</span></span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;      <span class="comment">//其他情况都是return root</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度: O(N)  ，其中 N 是树的节点数。对每个节点访问一次。</li><li>空间复杂度: O(H)  H为树的高度，空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 (logN)。     </li></ul><br/><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉树的公共祖先</a></p><p>这道题跟上面就只有搜索树的区别，首先想到的也是递归，<br>p q的落点只有三种情况：二左/二右/一左一右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || p == root || q == root) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode l = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode r = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span> &amp;&amp; r == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span>) <span class="keyword">return</span> r; <span class="comment">// 如果在左子树中 p和 q都找不到，则 p和 q一定都在右子树中，</span></span><br><span class="line">        <span class="comment">//右子树中先遍历到的那个就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r == <span class="keyword">null</span>) <span class="keyword">return</span> l; <span class="comment">// 否则，如果 left不为空，在左子树中有找到节点（p或q），</span></span><br><span class="line">        <span class="comment">//这时候要再判断一下右子树中的情况，如果在右子树中，p和q都找不到，则 p和q一定</span></span><br><span class="line">        <span class="comment">//都在左子树中，左子树中先遍历到的那个就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root; <span class="comment">//否则，当 left和 right均不为空时，说明 p、q节点分别在 root异侧</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度: O(N)  ，其中 N 是树的节点数，最差情况下需要对每个节点访问一次。</li><li>空间复杂度: O(H)  H为树的高度，空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 (logN)。 </li></ul><p><br/><br/></p><h2 id="4、二叉树的三种遍历-递归非递归-✔"><a href="#4、二叉树的三种遍历-递归非递归-✔" class="headerlink" title="4、二叉树的三种遍历-递归非递归  ✔"></a>4、二叉树的三种遍历-递归非递归 <font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a></p><p><strong>递归方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();    <span class="comment">//定义在外部 才不会因为递归被重复定义</span></span><br><span class="line">      <span class="comment">//看答案都是重新定义一个方法,我这应该算偷懒了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preorderTraversal(root.left);</span><br><span class="line">            preorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归方法:</strong><br>实际上非递归的方法也是模拟递归的套路，递归用的是系统栈，而迭代的方法则是自己定义一个Stack来模拟递归的压栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                stack.push(node);   <span class="comment">//将该节点压栈,用于待会访问右节点</span></span><br><span class="line">                node = node.left;   </span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度: O(N)  ，其中 N 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度: O(H) ， H为树的高度，空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 (logN)。 </li></ul><p><br/><br/></p><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></p><p>因为递归的方法代码都相同，所以下面只研究非递归方法的代码</p><p><strong>非递归方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            res.add(cur.val);      <span class="comment">//与前序遍历基本相同,只是把添加root的值的步骤放到了这里</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">二叉树的后序遍历</a></p><p><strong>非递归方法:</strong><br>后序遍历和前序中序有所不同，看了题解之后有两种解法：</p><p><strong>解法一：</strong><br> 因为后序遍历的顺序是 <strong>左–&gt;右–&gt;中</strong>，可以利用双向链表，当我们遍历的顺序是 <strong>中–&gt;右–&gt;左</strong> 时， 遍历后<strong>将结果插入链表的头部</strong>而非尾部，那么结果链表就变为了：<strong>左–&gt;右–&gt;中</strong>，正好就是我们想要的顺序</p><p><strong>基于这两个思路，我们想一下如何处理：</strong></p><ul><li>修改前序遍历代码中，节点写入结果链表的代码，将插入队尾修改为插入队首</li><li>修改前序遍历代码中，每次先查看左节点再查看右节点的逻辑，变为先查看右节点再查看左节点</li></ul><p><strong>理清逻辑之后代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//这里相较于前序中序遍历换成了LinkedList，其它地方基本没有变化</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.addFirst(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><p><strong>解法二：</strong><br>还是类似前序中序的代码，但是因为弹栈的问题无法将根节点的值在最后再添加，所以如果遍历到右节点时如果右节点不为空 则将根节点再次压栈</p><p><br/><br/><br/><br/></p><h1 id="递归、回溯、分治"><a href="#递归、回溯、分治" class="headerlink" title="递归、回溯、分治"></a>递归、回溯、分治</h1><p><strong>回溯三部曲:</strong></p><ol><li><strong>确定参数、返回值</strong></li><li><strong>确定终止条件</strong></li><li><strong>确定单层搜索逻辑</strong></li></ol><br/><h2 id="1、n皇后-✔"><a href="#1、n皇后-✔" class="headerlink" title="1、n皇后 ✔"></a>1、n皇后<font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/n-queens/">n皇后</a></p><p>经典回溯题</p><p><strong>代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        backTracking(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] line = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">        Arrays.fill(line, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="comment">// 同一层为同一行的不同选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isVaild(n, row, col)) &#123;   <span class="comment">// 验证可以放Queen</span></span><br><span class="line">                <span class="comment">// 做出选择</span></span><br><span class="line">                line[col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                path.add(<span class="keyword">new</span> String(line));</span><br><span class="line"></span><br><span class="line">                backTracking(n, row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 撤销选择</span></span><br><span class="line">                line[col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isVaild</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path.get(i).charAt(col) == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左上角一条线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">             <span class="keyword">if</span> (path.get(i).charAt(j) == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查右上角一条线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (path.get(i).charAt(j) == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><p><a href="https://leetcode-cn.com/problems/n-queens-ii/">n皇后 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        backTracking(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] line = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">        Arrays.fill(line, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(n, row, col)) &#123;</span><br><span class="line">                <span class="comment">// 做出选择</span></span><br><span class="line">                line[col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                path.add(<span class="keyword">new</span> String(line));</span><br><span class="line">                backTracking(n, row + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 撤销选择</span></span><br><span class="line">                line[col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证列合法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path.get(i).charAt(col) == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证左上角一条线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path.get(i).charAt(j) == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证右上角一条线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path.get(i).charAt(j) == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="2、生成括号-✔"><a href="#2、生成括号-✔" class="headerlink" title="2、生成括号   ✔"></a>2、生成括号  <font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></p><p><strong>思路：</strong></p><ol><li>不需要用到循环，如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。</li></ol><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder path = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(path,n,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(StringBuilder path,<span class="keyword">int</span> n,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">length</span>() == n*<span class="number">2</span>)&#123;</span><br><span class="line">            res.<span class="built_in">add</span>(path.<span class="built_in">toString</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(left &lt; n)&#123;</span><br><span class="line">            path.<span class="built_in">append</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="built_in">backtracking</span>(path,n,left + <span class="number">1</span>,right);</span><br><span class="line">            path.<span class="built_in">deleteCharAt</span>(path.<span class="built_in">length</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; left)&#123;      <span class="comment">//这一步很重要</span></span><br><span class="line">            path.<span class="built_in">append</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="built_in">backtracking</span>(path,n,left,right + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">deleteCharAt</span>(path.<span class="built_in">length</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="3、求子集I-II-✔"><a href="#3、求子集I-II-✔" class="headerlink" title="3、求子集I II  ✔"></a>3、求子集I II <font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/subsets/">子集</a></p><p><strong>思路:</strong></p><ul><li>常规的回溯题目，但是需要注意的是终止条件的定义，因为题目要求的是返回所有集合，所以其实并不需要加上判断和return，就可以完成</li></ul><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="built_in">subsets</span>(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义参数 返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义终止条件  这里并不需要定义终止条件</span></span><br><span class="line">        res.<span class="built_in">add</span>(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex;i &lt; nums.length;i++)&#123;</span><br><span class="line">            path.<span class="built_in">addLast</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">removeLast</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><p><a href="https://leetcode-cn.com/problems/subsets-ii/">子集 II</a></p><p><strong>思路：</strong></p><ul><li>常见的套路，只需要先把数组排序 再在单层搜索逻辑中判断是否与前一位相同，如果相同跳过这次循环即可</li></ul><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="built_in">subsetsWithDup</span>(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.<span class="built_in">sort</span>(nums);</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        res.<span class="built_in">add</span>(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; startIndex &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.<span class="built_in">addLast</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">removeLast</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="4、组合数之和-✔"><a href="#4、组合数之和-✔" class="headerlink" title="4、组合数之和  ✔"></a>4、组合数之和 <font color=green> ✔</font></h2><p><a href="https://leetcode-cn.com/problems/combination-sum/">组合总和</a></p><p><strong>思路:</strong></p><ol><li>使用回溯法，先确定参数：<strong>int[] candidates ， int target</strong> ， int sum，<strong>int startIndex</strong> ， 但是通过观察发现我们可以使用 target - candidates[i] 来代替 sum 的作用，所以参数确定为 <strong>int[] candidates ， int target</strong> ，<strong>int startIndex</strong> </li><li>终止条件确定为：<br>当 target - candidates[i] &lt; 0 时，则这时的总和已经超过target，直接return<br>当 target - candidates[i] == 0 时，这时的总和正好等于target，将path存入res中，return</li><li>单层循环逻辑确定为：<br>backtracking(candidates,target-candidates[i],i);<br>因为数组中的数字可以重复使用，所以下一次搜索依旧从 i 开始</li><li>剪枝操作：<br><strong>先将数组排序（这是剪枝前提）</strong><br>当 进入循环时 target -  candidates[i] 已经 &lt; 0 了 ， 我们就不用再将这个循环继续下去了，直接break</li></ol><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="built_in">combinationSum</span>(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       Arrays.<span class="built_in">sort</span>(candidates);</span><br><span class="line">       <span class="built_in">backtracking</span>(candidates,target,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.确定返回值,参数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = candidates.length;</span><br><span class="line">       <span class="comment">//2.确定终止条件</span></span><br><span class="line">       <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">           res.<span class="built_in">add</span>(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.确定单层循环逻辑     4.剪枝  </span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex;i &lt; n;i++)&#123;</span><br><span class="line">           <span class="comment">// 重点理解这里剪枝，前提是候选数组已经有序，</span></span><br><span class="line">           <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           path.<span class="built_in">addLast</span>(candidates[i]);</span><br><span class="line">           <span class="built_in">backtracking</span>(candidates,target-candidates[i],i);</span><br><span class="line">           path.<span class="built_in">removeLast</span>();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">组合总和 II</a></p><p>这道题几乎和上面一样，只限制了数组中的数字不能重复使用，并且答案集合中不能出现重复的数组</p><p><strong>思路：</strong></p><ol><li> 确定参数返回值、确定终止条件，这两步都跟上一题一样</li><li>确定单层搜索逻辑：    <strong>在这里要加一个判断，判断当前这个元素是否跟上一个一样，如果一样那将会产生相同的结果，所以直接continue</strong><br>backtracking(candidates,target - candidates[i],i + 1);<br>数组中的数字不可以重复使用，所以下一次搜索从 i + 1 开始</li><li>剪枝操作：<br> <strong>先将数组排序（这是剪枝前提）</strong><br> 当 进入循环时 target -  candidates[i] 已经 &lt; 0 了 ， 我们就不用再将这个循环继续下去了，直接break</li></ol><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="built_in">combinationSum2</span>(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.<span class="built_in">sort</span>(candidates);</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定参数 返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">add</span>(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定循环单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;    <span class="comment">//剪枝</span></span><br><span class="line">            <span class="comment">/*这个if判断，保证了解集不包含重复组合</span></span><br><span class="line"><span class="comment">            只要数组中索引i处的值 等于 它前一个索引的值，就直接continue跳过*/</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; startIndex &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">addLast</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates,target - candidates[i],i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">removeLast</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><h2 id="5、岛屿问题-✔"><a href="#5、岛屿问题-✔" class="headerlink" title="5、岛屿问题  ✔"></a>5、岛屿问题 <font color=green> ✔</font></h2><blockquote><p><a href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">岛屿类问题的通用解法、DFS框架</a></p></blockquote><p><a href="https://leetcode-cn.com/problems/max-area-of-island/">岛屿的最大面积</a></p><p><strong>思路：</strong></p><p> 这道题目只需要对每个岛屿做 DFS 遍历，求出每个岛屿的面积就可以了。求岛屿面积的方法也很简单，每遍历到一个格子，就把面积 + 1，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = area(grid,i,j);</span><br><span class="line">                    res = Math.max(res,temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否在区域内</span></span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid,i,j)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断是否是未走过的陆地</span></span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果是陆地就将1改为2</span></span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>   <span class="number">1</span></span><br><span class="line">                +area(grid,i+<span class="number">1</span>,j)</span><br><span class="line">                +area(grid,i-<span class="number">1</span>,j)</span><br><span class="line">                +area(grid,i,j+<span class="number">1</span>)</span><br><span class="line">                +area(grid,i,j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; grid.length &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; grid[<span class="number">0</span>].length; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><p><a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿数量</a></p><p><strong>思路：</strong><br>每次遍历到 grid[i][j]  就按照dfs思路遍历并将 grid[i][j] = 2</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid,i,j)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] != <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j); </span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j); </span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>); </span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/></p><p><a href="https://leetcode-cn.com/problems/making-a-large-island/">最大人工岛</a></p><p><strong>思路：</strong></p><ul><li>先dfs遍历一次，求出每一块陆地的面积，并且把不同的陆地打上不同的编号</li><li>用HashMap将陆地的编号 面积存起来</li><li>再次遍历，这次遍历要找到每一块海洋，然后假设这个格子填充，把上下左右是陆地的格子所在的岛屿连接起来</li><li><strong>使用findneighbour方法</strong>找到上下左右的陆地邻居，并且这里<strong>需要用HashSet存储去重</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于海洋格子，找到上下左右</span></span><br><span class="line">    <span class="comment">// 每个方向，都要确保有效inArea以及是陆地格子，则表示是该海洋格子的陆地邻居  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashSet&lt;Integer&gt; <span class="title">findNeighbour</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">if</span>(inArea(grid,i+<span class="number">1</span>,j) &amp;&amp; grid[i+<span class="number">1</span>][j] != <span class="number">0</span>)&#123;</span><br><span class="line">            set.add(grid[i+<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inArea(grid,i-<span class="number">1</span>,j) &amp;&amp; grid[i-<span class="number">1</span>][j] != <span class="number">0</span>)&#123;</span><br><span class="line">            set.add(grid[i-<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inArea(grid,i,j+<span class="number">1</span>) &amp;&amp; grid[i][j+<span class="number">1</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            set.add(grid[i][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inArea(grid,i,j-<span class="number">1</span>) &amp;&amp; grid[i][j-<span class="number">1</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            set.add(grid[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><ul><li>遍历set取出 index 再找对应的面积 求出total，遍历完成return最大的total</li></ul><p><strong>完整代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, index = <span class="number">2</span>; <span class="comment">// 因为陆地为1 所以标记从2开始</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; areas = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">// 遍历求出每块陆地的面积，并打上编号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = area(grid,i,j,index);   <span class="comment">// 每次dfs的面积</span></span><br><span class="line">                    areas.put(index,temp);     <span class="comment">// 将编号 面积存入hashmap</span></span><br><span class="line">                    res = Math.max(res,temp);   <span class="comment">// 将最大值存入res</span></span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// 如果res = 0 说明没有陆地，返回1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次遍历，这次遍历要找到每一块海洋，然后假设这个格子填充，把上下左右是陆地的格子所在的岛屿连接起来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    HashSet&lt;Integer&gt; set = findNeighbour(grid,i,j);  <span class="comment">// 接受findNeighbour传过来的set</span></span><br><span class="line">                    <span class="keyword">if</span> (set.size() &lt; <span class="number">1</span>) <span class="keyword">continue</span>;    <span class="comment">// 如果海洋格子周围没有格子不必计算</span></span><br><span class="line">                    <span class="keyword">int</span> total = <span class="number">1</span>;      <span class="comment">// 填充这个格子，初始为1，这个变量记录合并岛屿后的面积</span></span><br><span class="line">                    <span class="keyword">for</span>(Integer k : set)&#123;</span><br><span class="line">                        total += areas.get(k);  <span class="comment">// 把面积加上</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    res = Math.max(res,total);  <span class="comment">// 比较得到最大的面积</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于海洋格子，找到上下左右</span></span><br><span class="line">    <span class="comment">// 每个方向，都要确保有效inArea以及是陆地格子，则表示是该海洋格子的陆地邻居  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashSet&lt;Integer&gt; <span class="title">findNeighbour</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">if</span>(inArea(grid,i+<span class="number">1</span>,j) &amp;&amp; grid[i+<span class="number">1</span>][j] != <span class="number">0</span>)&#123;</span><br><span class="line">            set.add(grid[i+<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inArea(grid,i-<span class="number">1</span>,j) &amp;&amp; grid[i-<span class="number">1</span>][j] != <span class="number">0</span>)&#123;</span><br><span class="line">            set.add(grid[i-<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inArea(grid,i,j+<span class="number">1</span>) &amp;&amp; grid[i][j+<span class="number">1</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            set.add(grid[i][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inArea(grid,i,j-<span class="number">1</span>) &amp;&amp; grid[i][j-<span class="number">1</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            set.add(grid[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid,i,j) || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 说明已经走过这块地</span></span><br><span class="line"></span><br><span class="line">        grid[i][j] = index;        <span class="comment">// 标记陆地</span></span><br><span class="line">        <span class="keyword">return</span>   <span class="number">1</span> </span><br><span class="line">                +area(grid,i+<span class="number">1</span>,j,index)</span><br><span class="line">                +area(grid,i-<span class="number">1</span>,j,index)</span><br><span class="line">                +area(grid,i,j+<span class="number">1</span>,index)</span><br><span class="line">                +area(grid,i,j-<span class="number">1</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/><br/><br/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021031213260843.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习记录" scheme="http://cmblogs.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="算法" scheme="http://cmblogs.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
